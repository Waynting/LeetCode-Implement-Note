// 自動生成的筆記數據文件 - 請勿手動編輯
export interface Note {
  id: string;
  title: string;
  category: 'dataStructure' | 'algorithm' | 'technique' | 'concept';
  topics: string[];
  difficulty: 'beginner' | 'intermediate' | 'advanced';
  description: string;
  contentPath: string;
  createdAt: string;
  updatedAt: string;
  markdownContent?: string;
}

export const NOTE_CATEGORIES = {
  dataStructure: 'Data Structures',
  algorithm: 'Algorithms',
  technique: 'Problem-Solving Techniques',
  concept: 'Core Concepts'
} as const;

export const NOTES: Note[] = [
  {
    "id": "backtracking",
    "title": "Backtracking",
    "category": "algorithm",
    "topics": [
      "Backtracking",
      "DFS",
      "Recursion"
    ],
    "difficulty": "intermediate",
    "description": "Backtracking explores all possible choices step by step, forming a decision tree. If a choice leads to a dead end, it backs up and tries another path.",
    "contentPath": "/content/notes/algorithms/backtracking.md",
    "createdAt": "2025-10-03",
    "updatedAt": "2025-10-03",
    "markdownContent": "# Backtracking\n\n## 概述\nBacktracking explores all possible choices step by step, forming a decision tree. If a choice leads to a dead end, it \"backs up\" (undoes the last decision) and tries another path.\n\n## 1. Core Concept (What & Why)\n- **Intuitive Explanation**: Backtracking explores all possible choices step by step, forming a decision tree. If a choice leads to a dead end, it \"backs up\" (undoes the last decision) and tries another path.\n- **Problem Types Solved**: subsets, permutations, combinations, partition problems, N-Queens, Sudoku, word search, constraint satisfaction.\n- **Applicable Conditions / Signals**: when we need **all solutions** (not just one), especially with branching decisions (choose / not choose, place / not place).\n- **Time / Space Complexity Target**: Usually O(k * number_of_solutions) / O(n) recursion depth.\n- **Common Data Structures**: recursion stack, vector/path to store current solution.\n\n---\n\n## 2. Invariants & Properties\n- **Core Invariants**:\n  - Each recursive call represents a decision state.\n  - Path (partial solution) must always be valid.\n- **How to Maintain**:\n  - Add element → recurse → remove element (restore state).\n- **Common Pitfalls**:\n  - Forgetting to backtrack (pop/remove), leading to wrong results.\n  - Not handling duplicates → repeated solutions.\n  - Incorrect base case → missing or extra solutions.\n\n---\n\n## 3. Common Solution Patterns\n- **Pattern A: Subsets (pick or not pick each element)**\n  - Thought Process: for each element, either include or skip → recurse deeper.\n  - Complexity: O(2^n).\n- **Pattern B: Combinations / Permutations**\n  - Thought Process: build partial sequence until size reached, avoid reuse if needed.\n  - Complexity: O(n!) for permutations, O(C(n, k)) for combinations.\n\n---\n\n## 4. Pseudocode (Language-Agnostic Skeleton)\n```text\nfunction dfs(index, path):\n    record(path)  # if problem requires\n    for i in range(index, n):\n        if i > index and nums[i] == nums[i-1]: continue  # skip duplicates\n        path.push(nums[i])\n        dfs(i+1, path)\n        path.pop()  # backtrack\n```\n\n---\n\n## 5. Syntax Cheat‑Sheet by Language\n\n### C++\n```cpp\nvector<vector<int>> ans;\nvector<int> path;\n\nvoid dfs(int start, vector<int>& nums) {\n    ans.push_back(path); // record current subset\n\n    for (int i = start; i < nums.size(); i++) {\n        if (i > start && nums[i] == nums[i-1]) continue; // skip duplicates\n        path.push_back(nums[i]);\n        dfs(i + 1, nums);\n        path.pop_back(); // backtrack\n    }\n}\n```\n\n---\n\n## 6. Minimal Working Example (MWE)\n- **Input**: nums = [1,2,2]\n- **Manual Steps**:\n  - [] → [1] → [1,2] → [1,2,2]\n  - Backtrack → [1,2] → backtrack → [1]\n  - Skip duplicate → [2], [2,2], []\n- **Output**: [[], [1], [1,2], [1,2,2], [2], [2,2]]\n- **Correctness**: every path corresponds to one subset, duplicates avoided.\n\n---\n\n## 7. Edge Cases & Tests\n```\nCase1: nums = [] → [[]]\nCase2: nums = [1] → [[], [1]]\nCase3: nums = [1,1] → [[], [1], [1,1]]\nCase4: nums = [1,2,2] → [[], [1], [1,2], [1,2,2], [2], [2,2]]\n```\n\n---\n\n## 8. Relation to Neighboring Concepts\n- Similar to DFS but applied on *choice trees* instead of graph traversal.\n- Can be combined with pruning (剪枝) to reduce search space.\n- Related to recursion, divide & conquer, and brute force.\n\n---\n\n## 9. Implementation Skeleton (Practice)\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        vector<vector<int>> ans;\n        vector<int> path;\n        dfs(0, nums, path, ans);\n        return ans;\n    }\n\nprivate:\n    void dfs(int start, vector<int>& nums, vector<int>& path, vector<vector<int>>& ans) {\n        // TODO: record current path\n        for (int i = start; i < nums.size(); i++) {\n            // TODO: skip duplicates at same depth\n            path.push_back(nums[i]);\n            dfs(i+1, nums, path, ans);\n            path.pop_back();\n        }\n    }\n};\n```\n\n---\n\n## 10. Common Problems\n- LeetCode:\n  - [ ] 78. Subsets\n  - [ ] 90. Subsets II\n  - [ ] 46. Permutations\n  - [ ] 77. Combinations\n  - [ ] 51. N-Queens\n- Other: classic Sudoku solver\n\n---\n\n## 11. Practice Plan\n- Day 0: implement subsets / subsets II\n- Day 2: do permutations, combinations\n- Day 7: N-Queens, Sudoku\n- Day 21: review + apply in constraint satisfaction problems\n\n---\n\n## 12. Personal Notes\n- Remember: \"add → recurse → remove\" is the mantra.\n- Always sort first when duplicates may appear.\n- Draw decision tree to visualize recursion flow.\n\n---\n\n## 13. References\n- CLRS, Backtracking chapter\n- LeetCode discussions (Subsets / Permutations / N-Queens)\n- CP-Algorithms: Backtracking basics\n"
  },
  {
    "id": "cpp-stl-set",
    "title": "STL `std::set` 中文速查（以實務使用為主）",
    "category": "dataStructure",
    "topics": [],
    "difficulty": "intermediate",
    "description": "暫無描述",
    "contentPath": "/content/notes/data-structures/cpp-stl-set.md",
    "createdAt": "2024-01-01",
    "updatedAt": "2025-10-05",
    "markdownContent": "# STL `std::set` 中文速查（以實務使用為主）\n\n> 以 C++17/20 為基準，標註新版特性（C++17/20/23）。`std::set` 為 **有序、唯一鍵** 的關聯式容器，通常以 **紅黑樹** 實作。\n\n---\n\n## 1. 什麼時候用 `std::set`？\n- 需要 **自動排序**、**不允許重複**、**可做有序查找（lower/upper_bound）**。\n- 若只在意是否存在、且追求平均 O(1) 查找：考慮 `std::unordered_set`。\n- 若需要重複鍵：用 `std::multiset`。\n\n---\n\n## 2. 關鍵特性與複雜度\n- 元素型別：`Key`（同時也是 value）。\n- 排序準則：`Compare`（預設 `std::less<Key>`，遞增）。\n- **唯一**：插入相同鍵會被忽略（或回報已存在）。\n- 迭代器：`bidirectional`（可 ++、--）。**元素為 const**（不能透過 iterator 改值）。\n- 主要操作複雜度（以 N = size）：\n  - `insert/emplace`：O(log N)\n  - `find/lower_bound/upper_bound`：O(log N)\n  - `erase(it)`：攤銷 O(1)（定位後刪除），`erase(key)`：O(log N)\n  - `merge`/`extract`：O(log N) 量級\n- 迭代器失效規則：\n  - **插入**不會使其他 iterator 失效。\n  - **刪除**會使被刪元素的 iterator 失效，其餘不受影響。\n\n---\n\n## 3. 常見操作範例（最小可用片段）\n\n### 3.1 建立 / 自訂比較器\n```cpp\n#include <set>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nstruct ByLenThenLex {\n    bool operator()(const string& a, const string& b) const {\n        if (a.size() != b.size()) return a.size() < b.size();\n        return a < b;\n    }\n};\n\nint main() {\n    set<int> s1 = {3,1,2,2};      // 自動去重 → {1,2,3}\n\n    set<string, ByLenThenLex> s2 = {\"bb\", \"a\", \"aaa\", \"ab\"};\n    // 排序規則：長度優先，再字典序 → {\"a\",\"bb\",\"ab\",\"aaa\"}\n\n    for (auto& x : s1) cout << x << ' ';   // 1 2 3\n}\n```\n\n### 3.2 插入 / 查找 / 刪除\n```cpp\nset<int> s;\n\nauto [it, inserted] = s.insert(10); // C++17 結構化綁定；insert 回傳 pair<iterator,bool>\ns.emplace(7);                       // 原地構造（對複雜型別更省）\ns.insert({5, 8, 12});               // initializer_list\n\nbool has7 = s.count(7) > 0;         // 或 C++20: s.contains(7)\nauto it5 = s.find(5);               // O(logN)，找不到回 end()\n\ns.erase(8);                         // 依 key 刪除（回傳刪除數量 0/1）\nif (it5 != s.end()) s.erase(it5);   // 依 iterator 刪除，回傳下一個 iterator（C++11 起）\n```\n\n### 3.3 有序查找（lower/upper/equal_range）\n```cpp\nset<int> s = {2,4,6,8};\n\nauto it = s.lower_bound(5);   // 第一個 >= 5 → 指向 6\nauto jt = s.upper_bound(6);   // 第一個 > 6  → 指向 8\nauto [l, r] = s.equal_range(6); // [l,r) 為等於 6 的範圍（在 set 中要嘛 0 要嘛 1 個）\n```\n\n### 3.4 異質查找（Heterogeneous lookup, C++14/17 透明比較器）\n不必先建立臨時 `std::string`，可用 `string_view` 或 `char*` 查找：\n```cpp\n#include <string_view>\nset<string, std::less<>> s = {\"alpha\",\"beta\",\"gamma\"}; // 注意 std::less<> 透明比較器\nbool has = s.contains(std::string_view(\"beta\"));       // C++20 contains\nauto it  = s.find(\"gamma\");                            // 直接用 char const*\n```\n\n### 3.5 變更元素鍵值？用 `extract`（C++17）\n`set` 元素是 const，**不能**直接 `*it = newKey`。需 `extract` 節點、改值、再插回：\n```cpp\nset<int> s = {1,3,5};\nauto nh = s.extract(3);        // node_handle\nnh.value() = 4;                // 改鍵值\ns.insert(move(nh));            // 插回（會依排序就位）\n```\n\n### 3.6 容器合併 `merge`（C++17）\n將另一個 set 中“可插入”的節點移入本 set（不複製，節點搬移）：\n```cpp\nset<int> a = {1,3,5};\nset<int> b = {2,3,4};\na.merge(b); // a: {1,2,3,4,5}, b: {3}（因 3 已存在，b 中保留衝突者）\n```\n\n### 3.7 範圍插入（C++23 `insert_range`）\n```cpp\n// C++23\nvector<int> v = {7,1,9,4};\ns.insert_range(v);        // 等同於依序 insert v 中元素\n```\n\n---\n\n## 4. 小抄 API（常用）\n- 構造：`set<Key,Compare,Allocator>`、`set(first,last)`、`set(init_list)`\n- 基本：`size()` / `empty()` / `clear()` / `swap()`\n- 插入：`insert(value)` / `insert(hint, value)` / `insert({..})` / `emplace(args...)` / `emplace_hint(hint, args...)` / **C++23** `insert_range(range)`\n- 查找：`find(key)` / `count(key)` / **C++20** `contains(key)` / `lower_bound(key)` / `upper_bound(key)` / `equal_range(key)`\n- 刪除：`erase(it)` / `erase(first,last)` / `erase(key)`\n- 節點操作（C++17）：`extract(key/it)` / `merge(other)`（搭配 `node_type`）\n- 迭代：`begin()` / `end()` / `rbegin()` / `rend()` / `cbegin()` / `cend()`\n- 比較器：`key_comp()` / `value_comp()`\n- 配置器：`get_allocator()`\n\n---\n\n## 5. 常見坑與最佳實踐\n1. **不要改元素值**：iterator 取到的是 `const Key&`。要改鍵用 `extract`。\n2. **邊迭代邊刪除**：使用回傳 iterator 的 `erase(it)` 模式：\n   ```cpp\n   for (auto it = s.begin(); it != s.end(); ) {\n       if (條件) it = s.erase(it);   // 回傳下一個\n       else      ++it;\n   }\n   ```\n3. **效能選擇**：純查存在性且不需排序→ `unordered_set`；需要順序/界限查找→ `set`。\n4. **自訂比較器需「嚴格弱序」**：確保 `!(a<b) && !(b<a)` 才視為相等，避免未定義行為。\n5. **大量插入**：若來源已近似排序，插入成本更低；批量插入可先放容器再 `merge`/`insert_range`（C++23）。\n6. **異質查找**：用透明比較器 `std::less<>`，避免不必要的臨時物件。\n\n---\n\n## 6. 典型練習題型\n- 維護一組**已訪集合**、**唯一值集合**。\n- 動態集合中的**第 k 小**（`set` + 迭代器移動 / 或 `order_of_key` in PBDS）。\n- 線段切割、區間端點去重與排序（配合 `lower_bound`/`upper_bound`）。\n- 去重並按自訂規則排序字串 / 結構體（自訂比較器）。\n\n---\n\n## 7. 迷你測試\n```cpp\nset<int> s = {5,1,5,3};\nassert(s.size() == 3);                 // {1,3,5}\nassert(*s.begin() == 1);\nassert(*prev(s.end()) == 5);\n\nauto it = s.lower_bound(4);            // → 5\nassert(it != s.end() && *it == 5);\n\ns.erase(3);                             // {1,5}\nauto nh = s.extract(5); nh.value() = 4; s.insert(move(nh)); // {1,4}\nassert(s.count(4) == 1);\n```\n\n---\n\n## 8. 備註\n- 內部多以平衡 BST（紅黑樹）實作；不同標準庫可能細節不同，但複雜度保證一致。\n- 舊編譯器對某些 C++20/23 API（如 `contains`、`insert_range`）可能不支援。\n\n"
  },
  {
    "id": "prefix-suffix-precompute",
    "title": "DSA Concept Note — Prefix / Suffix Precomputation & Applications",
    "category": "technique",
    "topics": [],
    "difficulty": "intermediate",
    "description": "暫無描述",
    "contentPath": "/content/notes/techniques/prefix-suffix-precompute.md",
    "createdAt": "2024-01-01",
    "updatedAt": "2025-10-05",
    "markdownContent": "# DSA Concept Note — Prefix / Suffix Precomputation & Applications\n\n## 0. Metadata\n- **Concept Name**: Prefix / Suffix Precomputation (Sums, Min/Max, Monotonicity, etc.)\n- **Category**: Algorithmic Preprocessing\n- **Tags**: prefix sum, suffix sum, prefix min/max, inc/dec flags, feasibility checks, difference array, 2D prefix sum, XOR prefix\n- **Prerequisites**: Arrays, basic math, time/space trade‑offs\n- **Familiarity (1–5)**: 3\n- **Last Updated**: 2025-10-05 (UTC+8)\n\n---\n\n## 1) Core Idea (What & Why)\n**Precompute cumulative information once → answer many queries or validate constraints in O(1)/O(log n).**\n- **Prefix** at index `i` summarizes data from the start up to `i` (e.g., sum/min/max/inc‑valid).\n- **Suffix** at index `i` summarizes data from `i` to the end.\n- Combine them to evaluate splits/cuts, ranges, and feasibility fast.\n\n**When to use**\n- Many **range** queries.\n- Need to check **feasibility at every cut** (e.g., prefix strictly increasing **and** suffix strictly decreasing).\n- Transform expensive per‑query cost → cheap constant time after O(n) preprocessing.\n\n---\n\n## 2) Canonical Constructions\n\n### 2.1 Prefix Sum (1D)\n- `pref[i] = a[0] + ... + a[i]` (64‑bit to avoid overflow)\n- Range sum `[l..r] = pref[r] − (l>0 ? pref[l‑1] : 0)`\n\n**C++ snippet**\n```cpp\nvector<long long> pref(n);\npref[0] = a[0];\nfor (int i = 1; i < n; ++i) pref[i] = pref[i-1] + a[i];\n\nauto range_sum = [&](int l, int r) -> long long {\n    return pref[r] - (l ? pref[l-1] : 0LL);\n};\n```\n\n### 2.2 Suffix Sum\n```cpp\nvector<long long> suff(n);\nsuff[n-1] = a[n-1];\nfor (int i = n-2; i >= 0; --i) suff[i] = suff[i+1] + a[i];\n```\n\n### 2.3 Prefix Min / Max & Suffix Min / Max\n- `pmin[i] = min(a[0..i])`, `pmax[i] = max(a[0..i])`\n- `smin[i] = min(a[i..n-1])`, `smax[i] = max(a[i..n-1])`\n\n### 2.4 Monotonicity Flags (inc/dec feasibility)\n- `inc[i] = inc[i-1] && (a[i-1] < a[i])` (strictly increasing prefix)\n- `dec[i] = dec[i+1] && (a[i] > a[i+1])` (strictly decreasing suffix)\n\n### 2.5 Prefix XOR / AND / OR / GCD\n- XOR: `px[i] = px[i-1] ^ a[i]` → range XOR in O(1).\n- GCD: `pg[i] = gcd(pg[i-1], a[i])`, `sg[i] = gcd(a[i], sg[i+1])` → range gcd via `gcd(pg[l-1], sg[r+1])`.\n\n### 2.6 Difference Array (range add in O(1), finalize by prefix)\n- To add `+v` on `[l..r]`: `diff[l] += v; diff[r+1] -= v;`\n- Recover: `arr = prefix(diff)`.\n\n### 2.7 2D Prefix Sum (Integral Image)\n- `P[i][j] = sum of A[0..i][0..j]`\n- Rectangle sum `(r1..r2, c1..c2)` via inclusion‑exclusion.\n\n---\n\n## 3) Typical Applications\n\n1. **Range Sum / XOR Queries**: RMQ alternative when only sums/XOR needed.\n2. **Balance / Split Problems**: minimize `|sum(left) − sum(right)|` subject to constraints.\n3. **Feasibility at a Cut**: e.g., `inc[i] && dec[i+1]` to ensure left is strictly increasing & right strictly decreasing.\n4. **Exclude‑one GCD**: `gcd of all except a[k] = gcd(pg[k-1], sg[k+1])`.\n5. **Threshold / Boundary Tests**: prefix min vs current, or suffix max vs current.\n6. **Difference Array**: many range updates + one pass to finalize.\n7. **2D Range Sums**: submatrix queries in O(1).\n\n---\n\n## 4) Pattern — \"Enumerate Cut with Feasibility Precompute\"\n**Goal**: Check quickly if a cut after `i` is valid, then evaluate a metric (e.g., sum difference).\n\n**Steps**\n1. Build `inc[0..i]` and `dec[i+1..]` flags.\n2. Build `pref` for O(1) left/right sums.\n3. Loop all `i` (0..n‑2), if feasible: compute metric and take min/max.\n\n**Pseudocode**\n```text\nbuild inc[], dec[], pref[]\nbest = +INF\nfor i in 0..n-2:\n    if inc[i] && dec[i+1]:\n        left  = pref[i]\n        right = pref[n-1] - pref[i]\n        best = min(best, |left - right|)\nreturn best or -1 if no feasible\n```\n\n---\n\n## 5) Edge Cases & Pitfalls\n- **Strict vs Non‑strict**: use `<` / `>` vs `<=` / `>=` correctly.\n- **Single‑element subarray**: often counts as strictly mono; confirm problem statement.\n- **Overflow**: use `long long` for sums; watch 2D sums.\n- **Indexing**: `pref[r] − pref[l-1]` pattern; guard `l=0`.\n- **Empty side**: when enumerating cuts, ensure both sides are non‑empty (`i ≤ n‑2`).\n- **2D boundaries**: inclusion‑exclusion off‑by‑one.\n- **Difference array finalize**: don't forget the final prefix pass.\n\n---\n\n## 6) Micro‑Exercises\n1. Build `inc[]` / `dec[]` for an array and count how many feasible cuts exist.\n2. Given `queries [l,r]`, answer `sum(l,r)` with `pref[]` and with `suff[]` (just to practice both).\n3. Implement \"range add updates + point queries\" with a 1D difference array.\n4. Implement 2D prefix sum and query a rectangle sum.\n5. Exclude‑one GCD with prefix/suffix GCD arrays.\n\n---\n\n## 7) Minimal C++ Skeletons\n\n**Prefix/Suffix sums & feasibility**\n```cpp\nvector<long long> pref(n);\npref[0] = a[0];\nfor (int i = 1; i < n; ++i) pref[i] = pref[i-1] + a[i];\n\nvector<char> inc(n, 0), dec(n, 0);\ninc[0] = 1;\nfor (int i = 1; i < n; ++i) inc[i] = inc[i-1] && (a[i-1] < a[i]);\ndec[n-1] = 1;\nfor (int i = n-2; i >= 0; --i) dec[i] = dec[i+1] && (a[i] > a[i+1]);\n```\n\n**Difference array**\n```cpp\nvector<long long> diff(n+1);\nauto add = [&](int l, int r, long long v){\n    diff[l] += v;\n    if (r+1 < (int)diff.size()) diff[r+1] -= v;\n};\nvector<long long> arr(n);\nlong long run = 0;\nfor (int i = 0; i < n; ++i) { run += diff[i]; arr[i] = run; }\n```\n\n**2D prefix (brief)**\n```cpp\nvector<vector<long long>> P(n+1, vector<long long>(m+1));\nfor (int i = 1; i <= n; ++i)\n  for (int j = 1; j <= m; ++j)\n    P[i][j] = A[i][j] + P[i-1][j] + P[i][j-1] - P[i-1][j-1];\n\nauto rect = [&](int r1,int c1,int r2,int c2){\n  return P[r2][c2]-P[r1-1][c2]-P[r2][c1-1]+P[r1-1][c1-1];\n};\n```\n\n---\n\n## 8) Related Concepts\n- Sliding window (when ranges are contiguous and move by 1).\n- Fenwick Tree / Segment Tree (range queries/updates with log factors).\n- Monotonic stack/queue (different \"monotonic\" but often paired with prefix info).\n- Sparse table (idempotent range queries like min/max).\n\n---\n\n## 9) Quick Checklist (Before Coding)\n- Decide strict vs non‑strict.\n- Choose 64‑bit sum if values can be large or many.\n- Confirm cut range (ensure both sides non‑empty).\n- Precompute only what you need (sum? min? flags? gcd?).\n- Add tests for `n=1/2`, equal elements, negatives, large values.\n\n---\n\n## 10) Personal Notes\n- For split‑array‑with‑constraints problems, **inc/dec + prefix sums** is a powerful O(n) pattern.\n- Difference arrays are great when there are **many range updates** but only one final read.\n- 2D prefix sum is often the fastest path for submatrix queries without updates.\n"
  }
];

export function getNotesByCategory(category: keyof typeof NOTE_CATEGORIES): Note[] {
  return NOTES.filter(note => note.category === category);
}

export function getNotesByTopic(topic: string): Note[] {
  return NOTES.filter(note => 
    note.topics.some(t => t.toLowerCase() === topic.toLowerCase())
  );
}

export function getNoteById(id: string): Note | undefined {
  return NOTES.find(note => note.id === id);
}
