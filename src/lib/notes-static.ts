// 自動生成的筆記數據文件 - 請勿手動編輯
export interface Note {
  id: string;
  title: string;
  category: 'dataStructure' | 'algorithm' | 'technique' | 'concept';
  topics: string[];
  difficulty: 'beginner' | 'intermediate' | 'advanced';
  description: string;
  contentPath: string;
  createdAt: string;
  updatedAt: string;
  markdownContent?: string;
}

export const NOTE_CATEGORIES = {
  dataStructure: 'Data Structures',
  algorithm: 'Algorithms',
  technique: 'Problem-Solving Techniques',
  concept: 'Core Concepts'
} as const;

export const NOTES: Note[] = [
  {
    "id": "backtracking",
    "title": "Backtracking",
    "category": "algorithm",
    "topics": [
      "Backtracking",
      "DFS",
      "Recursion"
    ],
    "difficulty": "intermediate",
    "description": "Backtracking explores all possible choices step by step, forming a decision tree. If a choice leads to a dead end, it backs up and tries another path.",
    "contentPath": "/content/notes/algorithms/backtracking.md",
    "createdAt": "2025-10-03",
    "updatedAt": "2025-10-03",
    "markdownContent": "# Backtracking\n\n## 概述\nBacktracking explores all possible choices step by step, forming a decision tree. If a choice leads to a dead end, it \"backs up\" (undoes the last decision) and tries another path.\n\n## 1. Core Concept (What & Why)\n- **Intuitive Explanation**: Backtracking explores all possible choices step by step, forming a decision tree. If a choice leads to a dead end, it \"backs up\" (undoes the last decision) and tries another path.\n- **Problem Types Solved**: subsets, permutations, combinations, partition problems, N-Queens, Sudoku, word search, constraint satisfaction.\n- **Applicable Conditions / Signals**: when we need **all solutions** (not just one), especially with branching decisions (choose / not choose, place / not place).\n- **Time / Space Complexity Target**: Usually O(k * number_of_solutions) / O(n) recursion depth.\n- **Common Data Structures**: recursion stack, vector/path to store current solution.\n\n---\n\n## 2. Invariants & Properties\n- **Core Invariants**:\n  - Each recursive call represents a decision state.\n  - Path (partial solution) must always be valid.\n- **How to Maintain**:\n  - Add element → recurse → remove element (restore state).\n- **Common Pitfalls**:\n  - Forgetting to backtrack (pop/remove), leading to wrong results.\n  - Not handling duplicates → repeated solutions.\n  - Incorrect base case → missing or extra solutions.\n\n---\n\n## 3. Common Solution Patterns\n- **Pattern A: Subsets (pick or not pick each element)**\n  - Thought Process: for each element, either include or skip → recurse deeper.\n  - Complexity: O(2^n).\n- **Pattern B: Combinations / Permutations**\n  - Thought Process: build partial sequence until size reached, avoid reuse if needed.\n  - Complexity: O(n!) for permutations, O(C(n, k)) for combinations.\n\n---\n\n## 4. Pseudocode (Language-Agnostic Skeleton)\n```text\nfunction dfs(index, path):\n    record(path)  # if problem requires\n    for i in range(index, n):\n        if i > index and nums[i] == nums[i-1]: continue  # skip duplicates\n        path.push(nums[i])\n        dfs(i+1, path)\n        path.pop()  # backtrack\n```\n\n---\n\n## 5. Syntax Cheat‑Sheet by Language\n\n### C++\n```cpp\nvector<vector<int>> ans;\nvector<int> path;\n\nvoid dfs(int start, vector<int>& nums) {\n    ans.push_back(path); // record current subset\n\n    for (int i = start; i < nums.size(); i++) {\n        if (i > start && nums[i] == nums[i-1]) continue; // skip duplicates\n        path.push_back(nums[i]);\n        dfs(i + 1, nums);\n        path.pop_back(); // backtrack\n    }\n}\n```\n\n---\n\n## 6. Minimal Working Example (MWE)\n- **Input**: nums = [1,2,2]\n- **Manual Steps**:\n  - [] → [1] → [1,2] → [1,2,2]\n  - Backtrack → [1,2] → backtrack → [1]\n  - Skip duplicate → [2], [2,2], []\n- **Output**: [[], [1], [1,2], [1,2,2], [2], [2,2]]\n- **Correctness**: every path corresponds to one subset, duplicates avoided.\n\n---\n\n## 7. Edge Cases & Tests\n```\nCase1: nums = [] → [[]]\nCase2: nums = [1] → [[], [1]]\nCase3: nums = [1,1] → [[], [1], [1,1]]\nCase4: nums = [1,2,2] → [[], [1], [1,2], [1,2,2], [2], [2,2]]\n```\n\n---\n\n## 8. Relation to Neighboring Concepts\n- Similar to DFS but applied on *choice trees* instead of graph traversal.\n- Can be combined with pruning (剪枝) to reduce search space.\n- Related to recursion, divide & conquer, and brute force.\n\n---\n\n## 9. Implementation Skeleton (Practice)\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        vector<vector<int>> ans;\n        vector<int> path;\n        dfs(0, nums, path, ans);\n        return ans;\n    }\n\nprivate:\n    void dfs(int start, vector<int>& nums, vector<int>& path, vector<vector<int>>& ans) {\n        // TODO: record current path\n        for (int i = start; i < nums.size(); i++) {\n            // TODO: skip duplicates at same depth\n            path.push_back(nums[i]);\n            dfs(i+1, nums, path, ans);\n            path.pop_back();\n        }\n    }\n};\n```\n\n---\n\n## 10. Common Problems\n- LeetCode:\n  - [ ] 78. Subsets\n  - [ ] 90. Subsets II\n  - [ ] 46. Permutations\n  - [ ] 77. Combinations\n  - [ ] 51. N-Queens\n- Other: classic Sudoku solver\n\n---\n\n## 11. Practice Plan\n- Day 0: implement subsets / subsets II\n- Day 2: do permutations, combinations\n- Day 7: N-Queens, Sudoku\n- Day 21: review + apply in constraint satisfaction problems\n\n---\n\n## 12. Personal Notes\n- Remember: \"add → recurse → remove\" is the mantra.\n- Always sort first when duplicates may appear.\n- Draw decision tree to visualize recursion flow.\n\n---\n\n## 13. References\n- CLRS, Backtracking chapter\n- LeetCode discussions (Subsets / Permutations / N-Queens)\n- CP-Algorithms: Backtracking basics\n"
  },
  {
    "id": "prefix-suffix-precompute",
    "title": "DSA Concept Note — Prefix / Suffix Precomputation & Applications",
    "category": "technique",
    "topics": [],
    "difficulty": "intermediate",
    "description": "暫無描述",
    "contentPath": "/content/notes/techniques/prefix-suffix-precompute.md",
    "createdAt": "2024-01-01",
    "updatedAt": "2025-10-05",
    "markdownContent": "# DSA Concept Note — Prefix / Suffix Precomputation & Applications\n\n## 0. Metadata\n- **Concept Name**: Prefix / Suffix Precomputation (Sums, Min/Max, Monotonicity, etc.)\n- **Category**: Algorithmic Preprocessing\n- **Tags**: prefix sum, suffix sum, prefix min/max, inc/dec flags, feasibility checks, difference array, 2D prefix sum, XOR prefix\n- **Prerequisites**: Arrays, basic math, time/space trade‑offs\n- **Familiarity (1–5)**: 3\n- **Last Updated**: 2025-10-05 (UTC+8)\n\n---\n\n## 1) Core Idea (What & Why)\n**Precompute cumulative information once → answer many queries or validate constraints in O(1)/O(log n).**\n- **Prefix** at index `i` summarizes data from the start up to `i` (e.g., sum/min/max/inc‑valid).\n- **Suffix** at index `i` summarizes data from `i` to the end.\n- Combine them to evaluate splits/cuts, ranges, and feasibility fast.\n\n**When to use**\n- Many **range** queries.\n- Need to check **feasibility at every cut** (e.g., prefix strictly increasing **and** suffix strictly decreasing).\n- Transform expensive per‑query cost → cheap constant time after O(n) preprocessing.\n\n---\n\n## 2) Canonical Constructions\n\n### 2.1 Prefix Sum (1D)\n- `pref[i] = a[0] + ... + a[i]` (64‑bit to avoid overflow)\n- Range sum `[l..r] = pref[r] − (l>0 ? pref[l‑1] : 0)`\n\n**C++ snippet**\n```cpp\nvector<long long> pref(n);\npref[0] = a[0];\nfor (int i = 1; i < n; ++i) pref[i] = pref[i-1] + a[i];\n\nauto range_sum = [&](int l, int r) -> long long {\n    return pref[r] - (l ? pref[l-1] : 0LL);\n};\n```\n\n### 2.2 Suffix Sum\n```cpp\nvector<long long> suff(n);\nsuff[n-1] = a[n-1];\nfor (int i = n-2; i >= 0; --i) suff[i] = suff[i+1] + a[i];\n```\n\n### 2.3 Prefix Min / Max & Suffix Min / Max\n- `pmin[i] = min(a[0..i])`, `pmax[i] = max(a[0..i])`\n- `smin[i] = min(a[i..n-1])`, `smax[i] = max(a[i..n-1])`\n\n### 2.4 Monotonicity Flags (inc/dec feasibility)\n- `inc[i] = inc[i-1] && (a[i-1] < a[i])` (strictly increasing prefix)\n- `dec[i] = dec[i+1] && (a[i] > a[i+1])` (strictly decreasing suffix)\n\n### 2.5 Prefix XOR / AND / OR / GCD\n- XOR: `px[i] = px[i-1] ^ a[i]` → range XOR in O(1).\n- GCD: `pg[i] = gcd(pg[i-1], a[i])`, `sg[i] = gcd(a[i], sg[i+1])` → range gcd via `gcd(pg[l-1], sg[r+1])`.\n\n### 2.6 Difference Array (range add in O(1), finalize by prefix)\n- To add `+v` on `[l..r]`: `diff[l] += v; diff[r+1] -= v;`\n- Recover: `arr = prefix(diff)`.\n\n### 2.7 2D Prefix Sum (Integral Image)\n- `P[i][j] = sum of A[0..i][0..j]`\n- Rectangle sum `(r1..r2, c1..c2)` via inclusion‑exclusion.\n\n---\n\n## 3) Typical Applications\n\n1. **Range Sum / XOR Queries**: RMQ alternative when only sums/XOR needed.\n2. **Balance / Split Problems**: minimize `|sum(left) − sum(right)|` subject to constraints.\n3. **Feasibility at a Cut**: e.g., `inc[i] && dec[i+1]` to ensure left is strictly increasing & right strictly decreasing.\n4. **Exclude‑one GCD**: `gcd of all except a[k] = gcd(pg[k-1], sg[k+1])`.\n5. **Threshold / Boundary Tests**: prefix min vs current, or suffix max vs current.\n6. **Difference Array**: many range updates + one pass to finalize.\n7. **2D Range Sums**: submatrix queries in O(1).\n\n---\n\n## 4) Pattern — \"Enumerate Cut with Feasibility Precompute\"\n**Goal**: Check quickly if a cut after `i` is valid, then evaluate a metric (e.g., sum difference).\n\n**Steps**\n1. Build `inc[0..i]` and `dec[i+1..]` flags.\n2. Build `pref` for O(1) left/right sums.\n3. Loop all `i` (0..n‑2), if feasible: compute metric and take min/max.\n\n**Pseudocode**\n```text\nbuild inc[], dec[], pref[]\nbest = +INF\nfor i in 0..n-2:\n    if inc[i] && dec[i+1]:\n        left  = pref[i]\n        right = pref[n-1] - pref[i]\n        best = min(best, |left - right|)\nreturn best or -1 if no feasible\n```\n\n---\n\n## 5) Edge Cases & Pitfalls\n- **Strict vs Non‑strict**: use `<` / `>` vs `<=` / `>=` correctly.\n- **Single‑element subarray**: often counts as strictly mono; confirm problem statement.\n- **Overflow**: use `long long` for sums; watch 2D sums.\n- **Indexing**: `pref[r] − pref[l-1]` pattern; guard `l=0`.\n- **Empty side**: when enumerating cuts, ensure both sides are non‑empty (`i ≤ n‑2`).\n- **2D boundaries**: inclusion‑exclusion off‑by‑one.\n- **Difference array finalize**: don't forget the final prefix pass.\n\n---\n\n## 6) Micro‑Exercises\n1. Build `inc[]` / `dec[]` for an array and count how many feasible cuts exist.\n2. Given `queries [l,r]`, answer `sum(l,r)` with `pref[]` and with `suff[]` (just to practice both).\n3. Implement \"range add updates + point queries\" with a 1D difference array.\n4. Implement 2D prefix sum and query a rectangle sum.\n5. Exclude‑one GCD with prefix/suffix GCD arrays.\n\n---\n\n## 7) Minimal C++ Skeletons\n\n**Prefix/Suffix sums & feasibility**\n```cpp\nvector<long long> pref(n);\npref[0] = a[0];\nfor (int i = 1; i < n; ++i) pref[i] = pref[i-1] + a[i];\n\nvector<char> inc(n, 0), dec(n, 0);\ninc[0] = 1;\nfor (int i = 1; i < n; ++i) inc[i] = inc[i-1] && (a[i-1] < a[i]);\ndec[n-1] = 1;\nfor (int i = n-2; i >= 0; --i) dec[i] = dec[i+1] && (a[i] > a[i+1]);\n```\n\n**Difference array**\n```cpp\nvector<long long> diff(n+1);\nauto add = [&](int l, int r, long long v){\n    diff[l] += v;\n    if (r+1 < (int)diff.size()) diff[r+1] -= v;\n};\nvector<long long> arr(n);\nlong long run = 0;\nfor (int i = 0; i < n; ++i) { run += diff[i]; arr[i] = run; }\n```\n\n**2D prefix (brief)**\n```cpp\nvector<vector<long long>> P(n+1, vector<long long>(m+1));\nfor (int i = 1; i <= n; ++i)\n  for (int j = 1; j <= m; ++j)\n    P[i][j] = A[i][j] + P[i-1][j] + P[i][j-1] - P[i-1][j-1];\n\nauto rect = [&](int r1,int c1,int r2,int c2){\n  return P[r2][c2]-P[r1-1][c2]-P[r2][c1-1]+P[r1-1][c1-1];\n};\n```\n\n---\n\n## 8) Related Concepts\n- Sliding window (when ranges are contiguous and move by 1).\n- Fenwick Tree / Segment Tree (range queries/updates with log factors).\n- Monotonic stack/queue (different \"monotonic\" but often paired with prefix info).\n- Sparse table (idempotent range queries like min/max).\n\n---\n\n## 9) Quick Checklist (Before Coding)\n- Decide strict vs non‑strict.\n- Choose 64‑bit sum if values can be large or many.\n- Confirm cut range (ensure both sides non‑empty).\n- Precompute only what you need (sum? min? flags? gcd?).\n- Add tests for `n=1/2`, equal elements, negatives, large values.\n\n---\n\n## 10) Personal Notes\n- For split‑array‑with‑constraints problems, **inc/dec + prefix sums** is a powerful O(n) pattern.\n- Difference arrays are great when there are **many range updates** but only one final read.\n- 2D prefix sum is often the fastest path for submatrix queries without updates.\n"
  }
];

export function getNotesByCategory(category: keyof typeof NOTE_CATEGORIES): Note[] {
  return NOTES.filter(note => note.category === category);
}

export function getNotesByTopic(topic: string): Note[] {
  return NOTES.filter(note => 
    note.topics.some(t => t.toLowerCase() === topic.toLowerCase())
  );
}

export function getNoteById(id: string): Note | undefined {
  return NOTES.find(note => note.id === id);
}
