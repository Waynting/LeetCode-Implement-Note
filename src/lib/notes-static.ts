// 自動生成的筆記數據文件 - 請勿手動編輯
export interface Note {
  id: string;
  title: string;
  category: 'dataStructure' | 'algorithm' | 'technique' | 'concept';
  topics: string[];
  difficulty: 'beginner' | 'intermediate' | 'advanced';
  description: string;
  contentPath: string;
  createdAt: string;
  updatedAt: string;
  markdownContent?: string;
}

export const NOTE_CATEGORIES = {
  dataStructure: 'Data Structures',
  algorithm: 'Algorithms',
  technique: 'Problem-Solving Techniques',
  concept: 'Core Concepts'
} as const;

export const NOTES: Note[] = [
  {
    "id": "backtracking",
    "title": "Backtracking（回溯法）",
    "category": "algorithm",
    "topics": [
      "Backtracking",
      "DFS",
      "Recursion"
    ],
    "difficulty": "intermediate",
    "description": "回溯法逐步探索所有可能的選擇，形成決策樹。若某選擇導致死路，則回退並嘗試另一條路徑。",
    "contentPath": "/content/notes/algorithms/backtracking.md",
    "createdAt": "2025-10-03",
    "updatedAt": "2025-10-03",
    "markdownContent": "# Backtracking（回溯法）\n\n## 概述\n回溯法逐步探索所有可能的選擇，形成決策樹。若某選擇導致死路，則「回退」（撤銷上一步決策）並嘗試另一條路徑。\n\n## 1. 核心概念（What & Why）\n- **直觀解釋**：回溯法逐步探索所有可能的選擇，形成決策樹。若某選擇導致死路，則「回退」（撤銷上一步決策）並嘗試另一條路徑。\n- **解決的問題類型**：子集、排列、組合、分割問題、N 皇后、數獨、單詞搜尋、約束滿足問題。\n- **適用條件 / 訊號**：當我們需要**所有解**（不只是一個解），特別是有分支決策時（選或不選、放或不放）。\n- **時間 / 空間複雜度目標**：通常 O(k * 解的數量) / O(n) 遞迴深度。\n- **常用資料結構**：遞迴堆疊、vector/path 來儲存當前解。\n\n---\n\n## 2. 不變性與性質\n- **核心不變性**：\n  - 每次遞迴呼叫代表一個決策狀態。\n  - 路徑（部分解）必須始終有效。\n- **如何維護**：\n  - 加入元素 → 遞迴 → 移除元素（恢復狀態）。\n- **常見陷阱**：\n  - 忘記回溯（pop/remove），導致錯誤結果。\n  - 未處理重複元素 → 產生重複解。\n  - 錯誤的基礎情況 → 遺漏或額外的解。\n\n---\n\n## 3. 常見解題模式\n- **模式 A：子集（對每個元素選或不選）**\n  - 思考過程：對每個元素，選擇包含或跳過 → 向下遞迴。\n  - 複雜度：O(2^n)。\n- **模式 B：組合 / 排列**\n  - 思考過程：建構部分序列直到達到目標大小，必要時避免重複使用。\n  - 複雜度：排列 O(n!)，組合 O(C(n, k))。\n\n---\n\n## 4. 虛擬碼（語言無關架構）\n```text\nfunction dfs(index, path):\n    record(path)  # 若問題需要\n    for i in range(index, n):\n        if i > index and nums[i] == nums[i-1]: continue  # 跳過重複\n        path.push(nums[i])\n        dfs(i+1, path)\n        path.pop()  # 回溯\n```\n\n---\n\n## 5. 各語言語法速查表\n\n### C++\n```cpp\nvector<vector<int>> ans;\nvector<int> path;\n\nvoid dfs(int start, vector<int>& nums) {\n    ans.push_back(path); // 記錄當前子集\n\n    for (int i = start; i < nums.size(); i++) {\n        if (i > start && nums[i] == nums[i-1]) continue; // 跳過重複\n        path.push_back(nums[i]);\n        dfs(i + 1, nums);\n        path.pop_back(); // 回溯\n    }\n}\n```\n\n---\n\n## 6. 最小可行範例（MWE）\n- **輸入**：nums = [1,2,2]\n- **手動步驟**：\n  - [] → [1] → [1,2] → [1,2,2]\n  - 回溯 → [1,2] → 回溯 → [1]\n  - 跳過重複 → [2], [2,2], []\n- **輸出**：[[], [1], [1,2], [1,2,2], [2], [2,2]]\n- **正確性**：每條路徑對應一個子集，避免了重複。\n\n---\n\n## 7. 邊界情況與測試\n```\nCase1: nums = [] → [[]]\nCase2: nums = [1] → [[], [1]]\nCase3: nums = [1,1] → [[], [1], [1,1]]\nCase4: nums = [1,2,2] → [[], [1], [1,2], [1,2,2], [2], [2,2]]\n```\n\n---\n\n## 8. 與相鄰概念的關係\n- 類似於 DFS，但應用於*選擇樹*而非圖遍歷。\n- 可與剪枝結合以減少搜尋空間。\n- 與遞迴、分治法、暴力搜尋相關。\n\n---\n\n## 9. 實作骨架（練習用）\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        vector<vector<int>> ans;\n        vector<int> path;\n        dfs(0, nums, path, ans);\n        return ans;\n    }\n\nprivate:\n    void dfs(int start, vector<int>& nums, vector<int>& path, vector<vector<int>>& ans) {\n        // TODO: 記錄當前路徑\n        for (int i = start; i < nums.size(); i++) {\n            // TODO: 在同一深度跳過重複\n            path.push_back(nums[i]);\n            dfs(i+1, nums, path, ans);\n            path.pop_back();\n        }\n    }\n};\n```\n\n---\n\n## 10. 常見題目\n- LeetCode:\n  - [ ] 78. Subsets\n  - [ ] 90. Subsets II\n  - [ ] 46. Permutations\n  - [ ] 77. Combinations\n  - [ ] 51. N-Queens\n- 其他：經典數獨解題器\n\n---\n\n## 11. 練習計畫\n- Day 0: 實作 subsets / subsets II\n- Day 2: 做 permutations、combinations\n- Day 7: N-Queens、Sudoku\n- Day 21: 複習 + 應用在約束滿足問題\n\n---\n\n## 12. 個人筆記\n- 記住：「加入 → 遞迴 → 移除」是口訣。\n- 當可能出現重複時，總是先排序。\n- 畫出決策樹以視覺化遞迴流程。\n\n---\n\n## 13. 參考資料\n- CLRS, Backtracking 章節\n- LeetCode 討論區（Subsets / Permutations / N-Queens）\n- CP-Algorithms: Backtracking 基礎\n"
  },
  {
    "id": "graph-traversal-bipartite",
    "title": "圖的基本遍歷與二分檢查（學習筆記）",
    "category": "algorithm",
    "topics": [],
    "difficulty": "intermediate",
    "description": "暫無描述",
    "contentPath": "/content/notes/algorithms/graph-traversal-bipartite.md",
    "createdAt": "2024-01-01",
    "updatedAt": "2025-10-12",
    "markdownContent": "> **用途**：本筆記作為入門與速查，聚焦「無向圖」的遍歷與二分檢查。  \n> **風格**：概念優先、流程清晰、只給**偽碼骨架**（不含可提交實作）。\n\n## 一、基本名詞與模型\n\n- **圖 (Graph)**：由「頂點（vertices）」與「邊（edges）」組成。本文默認**無向簡單圖**（不含自環與重邊）。\n- **表示法**：\n  - **鄰接表**：`adj[v]` 存所有與 `v` 相鄰的頂點。空間 ~ `O(N + M)`，遍歷友好。\n  - **鄰接矩陣**：`mat[v][u]` 是否有邊。空間 ~ `O(N^2)`，適合密集圖、小圖。\n- **連通分量 (Connected Component)**：圖可分成幾塊彼此可達的子圖；遍歷時常需要**從每個未訪問點**重新起始。\n\n## 二、遍歷總覽：BFS 與 DFS\n\n### 2.1 BFS（廣度優先）\n- **核心**：分層擴張，使用**佇列**。適合最短邊數距離、二分染色。\n- **不變量**：\n  1. 佇列中的點，其距離層級（從起點）不遞減。\n  2. 每條已出佇列的點都已處理過鄰居。\n\n**偽碼骨架（單源起點 `s`）**\n```\nqueue Q\nmark s as visited\nQ.push(s)\nwhile Q not empty:\n    v = Q.pop()\n    for each neighbor u of v:\n        if u not visited:\n            mark u as visited\n            Q.push(u)\n```\n> 多分量時：對每個未訪問節點 `x`，各自啟動一次 BFS。\n\n### 2.2 DFS（深度優先）\n- **核心**：一路深入再回溯，**遞迴或顯式堆疊**。\n- **觀念**：會自然生成 DFS 樹，可辨識「樹邊／回邊」，在無向圖中**回邊**代表存在環。\n\n**偽碼骨架（遞迴版）**\n```\nfunction DFS(v, parent):\n    mark v as visited\n    for each neighbor u of v:\n        if u not visited:\n            DFS(u, v)\n        else if u != parent:\n            # 在無向圖中出現回邊 → 有環\n```\n> 遞迴深度可能達 `N`；在工程中可改成顯式堆疊。\n\n### 2.3 連通分量的取得\n```\nfor v in 1..N:\n    if v not visited:\n        # 以 v 為新分量起點\n        run BFS/DFS from v\n```\n\n## 三、二分圖（Bipartite）與奇環\n\n- **定義**：可把頂點分成兩色（黑/白），**每條邊兩端顏色不同**。\n- **等價條件（無向圖）**：**沒有奇數長度的環（奇環）** ⇔ 是二分圖。\n- **直觀**：BFS/DFS 以「層級奇偶」作為顏色；若遇到一條邊連到**相同顏色**的點 → 發生**顏色衝突** ⇒ 有奇環 ⇒ 非二分。\n\n## 四、二分檢查：遍歷 + 染色\n\n### 4.1 流程概念\n1. **多分量**：對每個未訪問節點作為起點。\n2. 起點染色（例如色 `0`），並以 BFS 或 DFS 擴張。\n3. 每當走到一條邊 `(v,u)`：\n   - 若 `u` 未染色：賦予 `u` = `1 - color[v]`。\n   - 若 `u` 已染色且 `color[u] == color[v]` → **衝突**（即存在奇環）→ 非二分。\n\n### 4.2 偽碼骨架（BFS 染色，多分量）\n```\ncolor[] = UNCOLORED\nfor each vertex s in 1..N:\n    if color[s] == UNCOLORED:\n        color[s] = 0\n        queue Q; Q.push(s)\n        while Q not empty:\n            v = Q.pop()\n            for u in adj[v]:\n                if color[u] == UNCOLORED:\n                    color[u] = 1 - color[v]\n                    Q.push(u)\n                else if color[u] == color[v]:\n                    return \"NOT BIPARTITE\"\nreturn \"BIPARTITE\"\n```\n> DFS 版本同理，只是把「推入佇列」換成「遞迴呼叫/壓入堆疊」。\n\n### 4.3 為什麼偵測到同色相鄰就是奇環？\n- BFS 的顏色就是**距離層級的奇偶性**；若存在邊連接**同層級奇偶性**的兩點，則形成一條**奇數長度環**（兩點由樹路徑相連，再加上該邊）。\n\n## 五、時間與空間複雜度\n\n- **時間**：`O(N + M)`，每條邊與節點皆至多被處理常數次。\n- **空間**：`O(N + M)`（鄰接表） + `O(N)`（佇列或遞迴堆疊）。\n\n## 六、常見陷阱與排錯心法\n\n1. **只從 1 起走、忽略其他分量** → 漏檢。  \n2. **把自環、重邊當成一般邊**：\n   - 自環（`v` 連 `v`）直接判「非二分」；\n   - **重邊**（`u`—`v` 重複）在無向圖不會單獨造成奇環，但要當作兩條平行邊處理輸入。\n3. **遞迴爆棧**：節點數大時用顯式堆疊或 BFS。  \n4. **顏色初始化**：務必把「未染色」與 `0/1` 區分清楚。  \n5. **索引混亂**：題目若 1-index，程式中 0-index 要一致轉換。  \n6. **方向誤解**：本文方法適用**無向圖**；有向圖的「二分圖」概念不同。\n\n## 七、延伸與變體（概念）\n\n- **邊權／點權**：二分檢查與權重無關（只看結構）。  \n- **找一個奇環證據**：衝突當下可沿父親指標回朔，輸出一條奇環（學術上常用）。  \n- **二分圖結構應用**：最大匹配（Hopcroft–Karp）、最小點覆蓋（Kőnig 定理）、網路流建模等。\n\n## 八、練習題建議（純題名，便於自查）\n- **785. Is Graph Bipartite?**（無向圖二分檢查基本題）  \n- **886. Possible Bipartition**（把人分兩派、衝突邊表示不能同色）  \n- **200. Number of Islands**（練 BFS/DFS 遍歷與分量計數）  \n- **547. Number of Provinces**（圖的分量）  \n- **994. Rotting Oranges**（BFS 層級擴張的節奏感）\n\n## 九、微練習（自我檢查）\n1. 為何「沒有奇環」就一定能二分染色？反方向又為何成立？  \n2. 若圖是一片森林（所有分量皆樹），需要做什麼就能保證二分？  \n3. 在 BFS 染色中，遇到 `(v,u)` 且 `color[u] == color[v]`，試用「樹路徑 + 這條邊」畫出對應奇環的構造。\n\n## 十、附錄：顯式堆疊的 DFS 染色骨架（僅供思路）\n```\nstack S\ncolor[s] = 0\nS.push(s)\nwhile S not empty:\n    v = S.pop()\n    for u in adj[v]:\n        if color[u] == UNCOLORED:\n            color[u] = 1 - color[v]\n            S.push(u)\n        else if color[u] == color[v]:\n            return \"NOT BIPARTITE\"\nreturn \"BIPARTITE\"\n```\n\n> **結語**：做題時，**先分量、後染色** 是穩定套路；BFS 尤其適合二分檢查。當你能自然從「衝突」回想到「奇環」，就算真的掌握了。\n"
  },
  {
    "id": "cpp-stl-map",
    "title": "STL std::map 速查",
    "category": "dataStructure",
    "topics": [
      "C++",
      "STL",
      "Map",
      "Data Structures"
    ],
    "difficulty": "intermediate",
    "description": "有序、唯一鍵的關聯式容器，平衡 BST 實作，依鍵排序。",
    "contentPath": "/content/notes/data-structures/cpp-stl-map.md",
    "createdAt": "2025-10-05",
    "updatedAt": "2025-10-05",
    "markdownContent": "# STL `std::map` 中文速查（以實務使用為主）\n\n> 以 C++17/20/23 為基準。`std::map<Key, T, Compare>` 是 **有序、唯一鍵** 的關聯式容器（平衡 BST，常見為紅黑樹）。元素型別為 `pair<const Key, T>`，**依鍵排序**。\n\n---\n\n## 1. 什麼時候用 `std::map`？\n- 需要 **自動排序** 與 **有序查找（lower/upper_bound）**。\n- 需要 **唯一鍵**，且常做範圍/邊界查詢。\n- 若只在意存在性/平均 O(1) 查找，不需順序 → `std::unordered_map`。\n- 若需要重複鍵 → `std::multimap`。\n\n---\n\n## 2. 關鍵特性與複雜度\n- 排序準則：`Compare`（預設 `std::less<Key>`，遞增）。\n- 迭代器：`bidirectional`（可 ++、--）。\n- **元素鍵為 const**（`pair<const Key, T>`），不可直接修改鍵值。\n- 典型操作複雜度（N = size）：\n  - `insert / emplace / find / lower_bound / upper_bound`：`O(log N)`\n  - `erase(key)`：`O(log N)`；`erase(it)`：定位後攤銷 `O(1)`\n  - `operator[]`：`O(log N)`，必要時 **插入預設值**（有副作用！）\n- 迭代器失效：\n  - **插入**不會使其他 iterator 失效。\n  - **刪除**會使被刪元素的 iterator 失效，其餘不影響。\n\n---\n\n## 3. 常見操作範例（最小可用片段）\n\n### 3.1 建立 / 自訂比較器\n```cpp\n#include <map>\n#include <string>\nusing namespace std;\n\nstruct ByLenThenLex {\n    bool operator()(const string& a, const string& b) const {\n        if (a.size() != b.size()) return a.size() < b.size();\n        return a < b;\n    }\n};\n\nmap<int, string> m1 = {{2,\"two\"}, {1,\"one\"}};  // 依 key 排序 → (1,\"one\"), (2,\"two\")\nmap<string, int, ByLenThenLex> m2;             // 自訂排序\n```\n\n### 3.2 插入 / 查找 / 修改值\n```cpp\nmap<string, int> cnt;\n\ncnt[\"apple\"]++;                 // 若不存在會插入 (\"apple\", 0) 再 ++\nauto [it, inserted] = cnt.insert({\"banana\", 3});   // C++17 結構化綁定\ncnt.emplace(\"cherry\", 5);                           // 就地建構\n\nauto it2 = cnt.find(\"banana\");    // O(logN)；找不到回 end()\nbool has = cnt.count(\"apple\") > 0; // 或 C++20: cnt.contains(\"apple\")\n\nif (it2 != cnt.end()) it2->second += 10;  // 修改 value\n```\n\n### 3.3 不想插入就查值：`at` 與 `find`（避免 `operator[]` 副作用）\n```cpp\n// operator[] 會在不存在時插入 default(T)！查值時容易誤插入\nint x = cnt[\"not_exist\"];     // ⚠️ 插入 (\"not_exist\", 0)（若 T=int）\n\nauto it3 = cnt.find(\"not_exist\");     // 建議查找用 find/contains\nif (it3 != cnt.end()) {\n    int v = it3->second;\n}\n\nint v2 = cnt.at(\"apple\");             // 存在才回傳；否則丟出 out_of_range\n```\n\n### 3.4 C++17 便利 API：`try_emplace` / `insert_or_assign`\n```cpp\nmap<string, string> mp;\n\n// 只有在 key 不存在時才建構 value（避免無謂拷貝）\nmp.try_emplace(\"k\", 10, 'x'); // value 以 string(10,'x') 原地建構\n\n// 若存在則覆蓋，否則插入\nmp.insert_or_assign(\"k\", \"new_value\");\n```\n\n### 3.5 有序查找（lower/upper/equal_range）\n```cpp\nmap<int,string> m = {{2,\"b\"},{4,\"d\"},{6,\"f\"}};\n\nauto it = m.lower_bound(5);    // 第一個 key >= 5 → 指向 (6,\"f\")\nauto jt = m.upper_bound(4);    // 第一個 key > 4  → 指向 (6,\"f\")\nauto [l, r] = m.equal_range(4);// 介於 [4,4] 的範圍 → 單點或空\n```\n\n### 3.6 異質查找（Heterogeneous lookup, C++14/17 透明比較器）\n```cpp\n#include <string_view>\nmap<string, int, std::less<>> mp = {{\"alpha\",1},{\"beta\",2}};\nbool has = mp.contains(std::string_view(\"beta\")); // C++20 contains\nauto it  = mp.find(\"alpha\");                      // 直接用 const char* 查找\n```\n\n### 3.7 節點操作 `extract` / 容器合併 `merge`（C++17）\n```cpp\nmap<int,string> a = {{1,\"one\"},{3,\"three\"}};\nmap<int,string> b = {{2,\"two\"},{3,\"tres\"}};\n\nauto nh = a.extract(1);   // 取出 node_handle（鍵可讀，值可改）\nnh.key() == 1;            // 鍵是 const? 對 map：鍵讀不可改，但可搬移節點\nnh.mapped() = \"uno\";      // 可改 value\nb.insert(move(nh));       // 插入到 b\n\na.merge(b); // 將 b 中可插入的節點移入 a；衝突鍵留在 b\n```\n\n### 3.8 刪除與「邊迭代邊刪」\n```cpp\nfor (auto it = cnt.begin(); it != cnt.end(); ) {\n    if (it->second == 0) it = cnt.erase(it);  // C++11: erase(it) 回傳下一個\n    else ++it;\n}\n// 依 key 刪除：cnt.erase(\"apple\");   // 回傳刪除數量 0/1\n```\n\n---\n\n## 4. API 小抄（常用）\n- 構造：`map()` / `map(comp)` / `map(first,last,comp)` / `map(init_list,comp)`\n- 查找：`find(key)` / `count(key)` / **C++20** `contains(key)` / `lower_bound(key)` / `upper_bound(key)` / `equal_range(key)`\n- 存取：`operator[](key)` / `at(key)` / `at(key) const`\n- 插入：`insert(value)` / `insert(hint, value)` / `emplace(args...)` / `emplace_hint(hint,args...)` / **C++17** `try_emplace(key,args...)` / **C++17** `insert_or_assign(key,obj)`\n- 刪除：`erase(it)` / `erase(first,last)` / `erase(key)` / **C++20** `erase_if(map, pred)`（非成員）\n- 節點：**C++17** `extract(key/it)` / `merge(other)`（`node_type`）\n- 迭代：`begin()` / `end()` / `rbegin()` / `rend()` / `cbegin()` / `cend()`\n- 比較器與配接：`key_comp()` / `value_comp()` / `get_allocator()`\n\n---\n\n## 5. 常見坑與最佳實踐\n1. **`operator[]` 會插入**：查值時慎用，避免誤插入預設值；純查用 `find/contains/at`。\n2. **不能直接改鍵**：鍵是 const。若要變更鍵，考慮 `extract` 後改 `node` 再插回（或刪了重插）。\n3. **自訂比較器要嚴格弱序**：確保 `!(a<b) && !(b<a)` 表示等價，否則行為未定。\n4. **效能選擇**：需要 O(1) 平均查找就用 `unordered_map`；需要順序/邊界查找用 `map`。\n5. **異質查找**：用 `std::less<>` 作為透明比較器，避免臨時物件（如 `string_view`）。\n6. **大量插入**：可先收集後一次 `insert` 範圍或 `merge`；鍵接近有序時效率更好。\n7. **迭代器穩定**：插入不失效、刪除僅影響被刪元素，但**不要**在循環中無條件 `++it` 後又 `erase`。\n\n---\n\n## 6. 典型練習題型\n- 頻率統計（字數、元素出現次數）。\n- 區間/事件按鍵排序後的掃描、上/下界查找。\n- LRU/Cache 混合（`map` + `list`，或考慮 `ordered_map` 替代）。\n- 自訂排序的字串/結構體映射。\n\n---\n\n## 7. 迷你測試\n```cpp\nmap<int,string> m;\nm[10] = \"ten\";                   // 插入\nm.insert({5,\"five\"});\nm.try_emplace(7, 3, 'x');        // \"xxx\"\nm.insert_or_assign(10, \"TEN\");\n\nauto it = m.lower_bound(6);      // → key=7\nm.erase(5);                      // 刪 key=5\n\nfor (auto& [k,v] : m) { /* 有序輸出 */ }\n```\n\n---\n\n## 8. 備註\n- 多數實作為紅黑樹，保證 `O(logN)` 操作與有序迭代。\n- 舊編譯器可能不支援 C++20/23 API（如 `contains`、`erase_if`、`insert_range`）。\n"
  },
  {
    "id": "cpp-stl-set",
    "title": "STL set ",
    "category": "dataStructure",
    "topics": [],
    "difficulty": "intermediate",
    "description": "暫無描述",
    "contentPath": "/content/notes/data-structures/cpp-stl-set.md",
    "createdAt": "2024-01-01",
    "updatedAt": "2025-10-12",
    "markdownContent": "# STL set \n\n> 以 C++17/20 為基準，標註新版特性（C++17/20/23）。`std::set` 為 **有序、唯一鍵** 的關聯式容器，通常以 **紅黑樹** 實作。\n\n---\n\n## 1. 什麼時候用 `std::set`？\n- 需要 **自動排序**、**不允許重複**、**可做有序查找（lower/upper_bound）**。\n- 若只在意是否存在、且追求平均 O(1) 查找：考慮 `std::unordered_set`。\n- 若需要重複鍵：用 `std::multiset`。\n\n---\n\n## 2. 關鍵特性與複雜度\n- 元素型別：`Key`（同時也是 value）。\n- 排序準則：`Compare`（預設 `std::less<Key>`，遞增）。\n- **唯一**：插入相同鍵會被忽略（或回報已存在）。\n- 迭代器：`bidirectional`（可 ++、--）。**元素為 const**（不能透過 iterator 改值）。\n- 主要操作複雜度（以 N = size）：\n  - `insert/emplace`：O(log N)\n  - `find/lower_bound/upper_bound`：O(log N)\n  - `erase(it)`：攤銷 O(1)（定位後刪除），`erase(key)`：O(log N)\n  - `merge`/`extract`：O(log N) 量級\n- 迭代器失效規則：\n  - **插入**不會使其他 iterator 失效。\n  - **刪除**會使被刪元素的 iterator 失效，其餘不受影響。\n\n---\n\n## 3. 常見操作範例（最小可用片段）\n\n### 3.1 建立 / 自訂比較器\n```cpp\n#include <set>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nstruct ByLenThenLex {\n    bool operator()(const string& a, const string& b) const {\n        if (a.size() != b.size()) return a.size() < b.size();\n        return a < b;\n    }\n};\n\nint main() {\n    set<int> s1 = {3,1,2,2};      // 自動去重 → {1,2,3}\n\n    set<string, ByLenThenLex> s2 = {\"bb\", \"a\", \"aaa\", \"ab\"};\n    // 排序規則：長度優先，再字典序 → {\"a\",\"bb\",\"ab\",\"aaa\"}\n\n    for (auto& x : s1) cout << x << ' ';   // 1 2 3\n}\n```\n\n### 3.2 插入 / 查找 / 刪除\n```cpp\nset<int> s;\n\nauto [it, inserted] = s.insert(10); // C++17 結構化綁定；insert 回傳 pair<iterator,bool>\ns.emplace(7);                       // 原地構造（對複雜型別更省）\ns.insert({5, 8, 12});               // initializer_list\n\nbool has7 = s.count(7) > 0;         // 或 C++20: s.contains(7)\nauto it5 = s.find(5);               // O(logN)，找不到回 end()\n\ns.erase(8);                         // 依 key 刪除（回傳刪除數量 0/1）\nif (it5 != s.end()) s.erase(it5);   // 依 iterator 刪除，回傳下一個 iterator（C++11 起）\n```\n\n### 3.3 有序查找（lower/upper/equal_range）\n```cpp\nset<int> s = {2,4,6,8};\n\nauto it = s.lower_bound(5);   // 第一個 >= 5 → 指向 6\nauto jt = s.upper_bound(6);   // 第一個 > 6  → 指向 8\nauto [l, r] = s.equal_range(6); // [l,r) 為等於 6 的範圍（在 set 中要嘛 0 要嘛 1 個）\n```\n\n### 3.4 異質查找（Heterogeneous lookup, C++14/17 透明比較器）\n不必先建立臨時 `std::string`，可用 `string_view` 或 `char*` 查找：\n```cpp\n#include <string_view>\nset<string, std::less<>> s = {\"alpha\",\"beta\",\"gamma\"}; // 注意 std::less<> 透明比較器\nbool has = s.contains(std::string_view(\"beta\"));       // C++20 contains\nauto it  = s.find(\"gamma\");                            // 直接用 char const*\n```\n\n### 3.5 變更元素鍵值？用 `extract`（C++17）\n`set` 元素是 const，**不能**直接 `*it = newKey`。需 `extract` 節點、改值、再插回：\n```cpp\nset<int> s = {1,3,5};\nauto nh = s.extract(3);        // node_handle\nnh.value() = 4;                // 改鍵值\ns.insert(move(nh));            // 插回（會依排序就位）\n```\n\n### 3.6 容器合併 `merge`（C++17）\n將另一個 set 中“可插入”的節點移入本 set（不複製，節點搬移）：\n```cpp\nset<int> a = {1,3,5};\nset<int> b = {2,3,4};\na.merge(b); // a: {1,2,3,4,5}, b: {3}（因 3 已存在，b 中保留衝突者）\n```\n\n### 3.7 範圍插入（C++23 `insert_range`）\n```cpp\n// C++23\nvector<int> v = {7,1,9,4};\ns.insert_range(v);        // 等同於依序 insert v 中元素\n```\n\n---\n\n## 4. 小抄 API（常用）\n- 構造：`set<Key,Compare,Allocator>`、`set(first,last)`、`set(init_list)`\n- 基本：`size()` / `empty()` / `clear()` / `swap()`\n- 插入：`insert(value)` / `insert(hint, value)` / `insert({..})` / `emplace(args...)` / `emplace_hint(hint, args...)` / **C++23** `insert_range(range)`\n- 查找：`find(key)` / `count(key)` / **C++20** `contains(key)` / `lower_bound(key)` / `upper_bound(key)` / `equal_range(key)`\n- 刪除：`erase(it)` / `erase(first,last)` / `erase(key)`\n- 節點操作（C++17）：`extract(key/it)` / `merge(other)`（搭配 `node_type`）\n- 迭代：`begin()` / `end()` / `rbegin()` / `rend()` / `cbegin()` / `cend()`\n- 比較器：`key_comp()` / `value_comp()`\n- 配置器：`get_allocator()`\n\n---\n\n## 5. 常見坑與最佳實踐\n1. **不要改元素值**：iterator 取到的是 `const Key&`。要改鍵用 `extract`。\n2. **邊迭代邊刪除**：使用回傳 iterator 的 `erase(it)` 模式：\n   ```cpp\n   for (auto it = s.begin(); it != s.end(); ) {\n       if (條件) it = s.erase(it);   // 回傳下一個\n       else      ++it;\n   }\n   ```\n3. **效能選擇**：純查存在性且不需排序→ `unordered_set`；需要順序/界限查找→ `set`。\n4. **自訂比較器需「嚴格弱序」**：確保 `!(a<b) && !(b<a)` 才視為相等，避免未定義行為。\n5. **大量插入**：若來源已近似排序，插入成本更低；批量插入可先放容器再 `merge`/`insert_range`（C++23）。\n6. **異質查找**：用透明比較器 `std::less<>`，避免不必要的臨時物件。\n\n---\n\n## 6. 典型練習題型\n- 維護一組**已訪集合**、**唯一值集合**。\n- 動態集合中的**第 k 小**（`set` + 迭代器移動 / 或 `order_of_key` in PBDS）。\n- 線段切割、區間端點去重與排序（配合 `lower_bound`/`upper_bound`）。\n- 去重並按自訂規則排序字串 / 結構體（自訂比較器）。\n\n---\n\n## 7. 迷你測試\n```cpp\nset<int> s = {5,1,5,3};\nassert(s.size() == 3);                 // {1,3,5}\nassert(*s.begin() == 1);\nassert(*prev(s.end()) == 5);\n\nauto it = s.lower_bound(4);            // → 5\nassert(it != s.end() && *it == 5);\n\ns.erase(3);                             // {1,5}\nauto nh = s.extract(5); nh.value() = 4; s.insert(move(nh)); // {1,4}\nassert(s.count(4) == 1);\n```\n\n---\n\n## 8. 備註\n- 內部多以平衡 BST（紅黑樹）實作；不同標準庫可能細節不同，但複雜度保證一致。\n- 舊編譯器對某些 C++20/23 API（如 `contains`、`insert_range`）可能不支援。\n\n"
  },
  {
    "id": "cpp-stl-unordered-map",
    "title": "STL std::unordered_map 速查",
    "category": "dataStructure",
    "topics": [
      "C++",
      "STL",
      "HashMap",
      "Data Structures"
    ],
    "difficulty": "intermediate",
    "description": "雜湊表的關聯式容器，鍵唯一、平均 O(1) 查找，無序。",
    "contentPath": "/content/notes/data-structures/cpp-stl-unordered-map.md",
    "createdAt": "2025-10-05",
    "updatedAt": "2025-10-05",
    "markdownContent": "# STL `std::unordered_map` 中文速查（以實務使用為主）\n\n> 以 C++17/20/23 為基準。`std::unordered_map<Key,T,Hash,KeyEq>` 是 **雜湊表** 的關聯式容器：\n> - **鍵唯一**、**平均 O(1)** 插入/查找/刪除；最壞 O(N)（碰撞嚴重時）。\n> - **無序**（迭代次序不保證），適合「只管是否存在/取值」而不需排序的情境。\n\n---\n\n## 1. 什麼時候用 `unordered_map`？\n- 需要 **平均 O(1) 查找**，不在意有序遍歷。\n- 作為 **計數器 / 查表**（hash table）比 `std::map` 快。\n- 鍵可為自訂型別（需提供 `Hash` 與 `KeyEq`）。\n- 若要範圍查詢（lower/upper_bound）或固定有序輸出→改用 `std::map`。\n\n---\n\n## 2. 關鍵特性與複雜度\n- 迭代器：`ForwardIterator`（只能 ++）。\n- 插入/查找/刪除：**平均 O(1)**；最壞 O(N)。\n- 重新雜湊（rehash）可能發生在：插入導致 **載入因子** 超過 `max_load_factor`。\n- **迭代器失效**：\n  - `rehash/ reserve`：**所有 iterators 失效**。\n  - `erase`：被刪的元素迭代器失效，其餘保持有效。\n  - 參考/指標：重雜湊通常 **不會** 使其失效（除非該元素被刪）。\n- 桶與負載：`bucket_count()`、`load_factor()`、`max_load_factor()`、`rehash(n)`、`reserve(n)`。\n\n---\n\n## 3. 常見操作範例（最小可用片段）\n\n### 3.1 基本增查改刪\n```cpp\n#include <unordered_map>\n#include <string>\nusing namespace std;\n\nunordered_map<string, int> freq;\n\nfreq[\"apple\"]++;                            // 若無則插入 (\"apple\",0) 再 ++\nauto [it, inserted] = freq.insert({\"a\", 1}); // C++17 結構化綁定\nfreq.emplace(\"b\", 2);                        // 原地建構\nfreq.insert_or_assign(\"b\", 5);               // 存在則賦值，不在則插入（C++17）\n\nauto it2 = freq.find(\"apple\");               // 平均 O(1)，找不到回 end()\nbool has = freq.count(\"banana\") > 0;         // C++20: freq.contains(\"banana\")\n\nif (it2 != freq.end()) it2->second += 10;    // 修改 value\nfreq.erase(\"a\");                              // 依 key 刪\n```\n\n### 3.2 預先保留容量、控制 rehash\n```cpp\nunordered_map<int, int> mp;\nmp.reserve(100000);               // 預留桶數以容納大概元素數（減少 rehash 次數）\nmp.max_load_factor(1.0f);         // 每桶平均允許的元素數（預設 ~1）\n```\n\n### 3.3 自訂雜湊與相等（自訂型別）\n```cpp\nstruct Point { int x, y; };\n\nstruct PointHash {\n    size_t operator()(const Point& p) const noexcept {\n        // 混合 x,y；簡化示例，實務可用更好的 hash 混合\n        return (std::hash<int>{}(p.x) * 1315423911u) ^ std::hash<int>{}(p.y);\n    }\n};\nstruct PointEq {\n    bool operator()(const Point& a, const Point& b) const noexcept {\n        return a.x == b.x && a.y == b.y;\n    }\n};\n\nunordered_map<Point, int, PointHash, PointEq> mp;\nmp[{3,4}] = 7;\n```\n\n### 3.4 異質查找（Heterogeneous lookup, **需要透明 hash/equal**）\n> 若提供的 `Hash` 和 `KeyEq` **支持透明比較**（C++20 常見模式：為它們提供 `is_transparent`），即可用相容鍵型別查找而不建臨時 Key。這通常需要**自訂** Hash/KeyEq；標準的 `std::hash<Key>` 本身不一定透明。\n```cpp\n// 伪碼/示意：Hash/KeyEq 需定義 is_transparent 並支援 string_view/const char* 等\nstruct TransparentHash { using is_transparent = void; /* ... */ };\nstruct TransparentEq   { using is_transparent = void; /* ... */ };\n\nunordered_map<string, int, TransparentHash, TransparentEq> mp2;\nbool ok = mp2.contains(std::string_view(\"hello\"));\n```\n\n### 3.5 節點與合併（C++17）\n```cpp\nunordered_map<int,string> a = {{1,\"one\"},{3,\"three\"}};\nunordered_map<int,string> b = {{2,\"two\"},{3,\"tres\"}};\n\nauto nh = a.extract(1);        // 取出 node_handle（鍵可讀，值可改）\nnh.mapped() = \"uno\";           // 改 value\nb.insert(move(nh));            // 插入到 b\n\na.merge(b);                    // 把 b 中可插入的節點搬到 a；衝突鍵留在 b\n```\n\n### 3.6 「邊迭代邊刪除」\n```cpp\nfor (auto it = freq.begin(); it != freq.end(); ) {\n    if (it->second == 0) it = freq.erase(it); // erase 回傳下一個 iterator\n    else ++it;\n}\n```\n\n---\n\n## 4. API 小抄（常用）\n- 構造：`unordered_map()` / `unordered_map(bucket_count)` / `unordered_map(first,last)` / `unordered_map(init_list)`\n- 查找：`find(key)` / `count(key)` / **C++20** `contains(key)`\n- 存取：`operator[](key)` / `at(key)` / `at(key) const`\n- 插入：`insert(value)` / `insert(hint,value)` / `insert(init_list)` / `emplace(args...)` / `try_emplace(key,args...)` / `insert_or_assign(key,obj)`\n- 刪除：`erase(it)` / `erase(first,last)` / `erase(key)` / **C++20** `erase_if(map, pred)`（非成員）\n- 桶與 rehash：`bucket_count()` / `bucket(key)` / `load_factor()` / `max_load_factor()` / `rehash(n)` / `reserve(n)` / `begin(n), end(n)`（桶級迭代）\n- 節點：**C++17** `extract(key/it)` / `merge(other)`（`node_type`）\n- 迭代：`begin()` / `end()` / `cbegin()` / `cend()`（次序不保證，且 rehash 會改變）\n\n---\n\n## 5. 常見坑與最佳實踐\n1. **rehash 會使所有 iterators 失效**：\n   - 在保留指標/iterator 之後 `insert` 可能觸發 rehash，導致失效。\n   - 若需要穩定：先 `reserve()` 足夠容量，或用 `std::map`。\n2. **`operator[]` 會插入預設值**：僅查值請用 `find/contains/at`，避免誤插。\n3. **鍵的 hash/equal 必須相容**：兩者的「相等」要對應到同樣的 hash 值域，否則行為退化或錯誤。\n4. **迭代次序不固定**：不要依賴輸出順序；若要排序輸出，拷貝鍵到 `vector` 後排序。\n5. **大量插入**：先 `reserve(N)`，減少 rehash 次數。\n6. **自訂型別 hash**：確保雜湊分布良好，避免碰撞造成性能下降。\n7. **異質查找**：需要自訂透明 Hash/KeyEq，否則預設不一定支援。\n\n---\n\n## 6. 典型練習題型\n- 次數統計（字頻、元素頻率）。\n- LRU/Cache 的 key→node 映射（通常配合 list）。\n- 兩數和/子陣列和等「查表」型解法。\n- 去重與存在性檢查（搭配 `unordered_set`）。\n\n---\n\n## 7. 迷你測試\n```cpp\nunordered_map<string,int> m;\nm.reserve(8);\nm[\"a\"] = 1; m[\"b\"] = 2; m[\"c\"] = 3;\n\nauto it = m.find(\"b\");\nif (it != m.end()) it->second += 10;\n\nm.erase(\"a\");\nfor (auto& [k,v] : m) { /* 無序輸出 */ }\n\n// 測 rehash 失效\nauto it2 = m.begin();\nm.insert({\"x\", 42});    // 可能 rehash\n// it2 可能失效，避免繼續使用\n```\n\n---\n\n## 8. 備註\n- 大部分實作採 **分離鏈結法（chaining）**：每個桶是一條鏈或小向量。\n- C++ 標準不保證 hash 分布與 rehash 策略，但提供負載因子介面讓你調整。\n- 舊編譯器對 C++20/23 的 `contains`、`erase_if` 等 API 支援度不一。\n\n"
  },
  {
    "id": "cpp-stl-unordered-set",
    "title": "STL std::unordered_set 速查",
    "category": "dataStructure",
    "topics": [
      "C++",
      "STL",
      "HashSet",
      "Data Structures"
    ],
    "difficulty": "intermediate",
    "description": "雜湊表的集合容器，元素唯一、平均 O(1) 查找，無序。",
    "contentPath": "/content/notes/data-structures/cpp-stl-unordered-set.md",
    "createdAt": "2025-10-05",
    "updatedAt": "2025-10-05",
    "markdownContent": "# STL `std::unordered_set` 中文速查（以實務使用為主）\n\n> 以 C++17/20/23 為基準。`std::unordered_set<T, Hash, KeyEq>` 是 **雜湊表** 的集合容器：\n> - **元素唯一**、**平均 O(1)** 插入/查找/刪除；最壞 O(N)（碰撞嚴重）。\n> - **無序**（迭代次序不保證），適合做「存在性檢查／去重」與快速查找。\n\n---\n\n## 1. 什麼時候用 `unordered_set`？\n- 只在意「是否存在」或需要 **平均 O(1) 查找**。\n- 要快速去重、記錄 visited、做 membership 查詢。\n- 若需要 **排序／有序遍歷／下界查找** → 用 `std::set`。\n- 若需要記錄次數（鍵→值） → 用 `std::unordered_map`。\n\n---\n\n## 2. 關鍵特性與複雜度\n- 迭代器：`ForwardIterator`（只能 ++）。\n- 插入/查找/刪除：**平均 O(1)**；碰撞嚴重時最壞 O(N)。\n- **rehash**（重雜湊）在桶數不足時發生，會：\n  - 使 **所有 iterators 失效**。\n  - 通常 **不會** 使指向元素的參考/指標失效（除非元素被刪）。\n- 容量與負載：`bucket_count()`、`load_factor()`、`max_load_factor()`、`rehash(n)`、`reserve(n)`。\n\n---\n\n## 3. 常見操作範例（最小可用片段）\n\n### 3.1 基本增查刪\n```cpp\n#include <unordered_set>\nusing namespace std;\n\nunordered_set<int> s;\n\nauto [it, inserted] = s.insert(10);    // C++17 結構化綁定\ns.emplace(7);                           // 原地建構（對複雜型別更省）\ns.insert({5, 8, 12});                   // initializer_list\n\nbool has7 = s.count(7) > 0;             // C++20: s.contains(7)\nauto it5 = s.find(5);                   // 平均 O(1)，找不到回 end()\n\ns.erase(8);                             // 依 key 刪除（回傳刪除數量 0/1）\nif (it5 != s.end()) s.erase(it5);       // 依 iterator 刪除，回傳下一個 iterator\n```\n\n### 3.2 預留容量／控制 rehash\n```cpp\nunordered_set<string> st;\nst.reserve(100000);            // 減少 rehash 次數\nst.max_load_factor(1.0f);      // 每桶平均允許元素數（預設約 1.0）\n```\n\n### 3.3 自訂雜湊與相等（自訂型別）\n```cpp\nstruct Point { int x, y; };\n\nstruct PointHash {\n    size_t operator()(const Point& p) const noexcept {\n        return (hash<int>{}(p.x) * 1315423911u) ^ hash<int>{}(p.y);\n    }\n};\nstruct PointEq {\n    bool operator()(const Point& a, const Point& b) const noexcept {\n        return a.x == b.x && a.y == b.y;\n    }\n};\n\nunordered_set<Point, PointHash, PointEq> ps;\nps.insert({3,4});\n```\n\n### 3.4 異質查找（Heterogeneous lookup，需透明 Hash/KeyEq）\n> 若 Hash/KeyEq 提供 `is_transparent` 並支援相容鍵型別，可避免建立臨時物件。\n```cpp\n// 示意：為 Hash/KeyEq 定義 using is_transparent = void;\nstruct TransparentHash { using is_transparent = void; /* ... */ };\nstruct TransparentEq   { using is_transparent = void; /* ... */ };\n\nunordered_set<string, TransparentHash, TransparentEq> st2;\nbool ok = st2.contains(std::string_view(\"hello\")); // C++20 contains\nauto it = st2.find(\"hello\");                       // 直接用 const char*\n```\n\n### 3.5 「邊迭代邊刪除」\n```cpp\nfor (auto it = s.begin(); it != s.end(); ) {\n    if (*it % 2 == 0) it = s.erase(it);  // erase 回傳下一個 iterator\n    else ++it;\n}\n```\n\n---\n\n## 4. API 小抄（常用）\n- 構造：`unordered_set()` / `unordered_set(bucket_count)` / `unordered_set(first,last)` / `unordered_set(init_list)`\n- 查找：`find(key)` / `count(key)` / **C++20** `contains(key)`\n- 插入：`insert(value)` / `insert(hint,value)` / `insert(init_list)` / `emplace(args...)`\n- 刪除：`erase(it)` / `erase(first,last)` / `erase(key)` / **C++20** `erase_if(set, pred)`（非成員）\n- 桶與 rehash：`bucket_count()` / `bucket(key)` / `load_factor()` / `max_load_factor()` / `rehash(n)` / `reserve(n)` / `begin(n), end(n)`（桶級迭代）\n- 迭代：`begin()` / `end()` / `cbegin()` / `cend()`（次序不保證，rehash 會改變）\n\n---\n\n## 5. 常見坑與最佳實踐\n1. **rehash 使所有 iterators 失效**：在保存 iterator 後進行插入可能觸發 rehash，請先 `reserve()`。\n2. **不要依賴迭代順序**：`unordered_set` 無序；若要排序輸出，拷貝到 `vector` 後 `sort`。\n3. **良好的雜湊與相等比較**：確保 `Hash` 與 `KeyEq` 一致且分布良好；碰撞多會降速。\n4. **大量插入**：預先 `reserve(N)`；適度調整 `max_load_factor()`。\n5. **異質查找**：需要自訂透明 Hash/KeyEq 才能用 `string_view`/`char*` 等相容鍵。\n6. **元素是唯一的**：若需要重複元素 → 請用 `unordered_multiset`。\n\n---\n\n## 6. 典型練習題型\n- 去重與存在性檢查（Two Sum 的輔助集合、子陣列和去重）。\n- 記錄 visited（BFS/DFS 狀態集合）。\n- 快速判斷字元/字串集合包含關係。\n- 流式資料的唯一元素統計（搭配 `unordered_map` 追數量）。\n\n---\n\n## 7. 迷你測試\n```cpp\nunordered_set<int> s = {1,2,3,2};\nassert(s.size() == 3);\n\nauto it = s.find(2);\nif (it != s.end()) s.erase(it);\ns.insert(100);\n\nsize_t b = s.bucket(100);           // 100 所在桶索引\nfloat lf = s.load_factor();         // 當前負載\ns.rehash(128);                      // 重雜湊到至少 128 桶（迭代器失效！）\n```\n\n---\n\n## 8. 與 `std::set` 對照（簡表）\n| 面向 | `unordered_set` | `set` |\n|---|---|---|\n| 存取複雜度 | 平均 O(1)，最壞 O(N) | O(log N) |\n| 是否有序 | 否 | 是（依 Compare 排序） |\n| 邊界查找 | 不支援 lower/upper_bound | 支援 |\n| 迭代器 | Forward（只能 ++） | Bidirectional（可 ++/--） |\n| 迭代穩定 | rehash 使所有 iterators 失效 | 插入不失效，刪除僅影響被刪元素 |\n\n---\n\n## 9. 備註\n- 常見實作為 **分離鏈結法（chaining）**：每桶是一條鏈或小陣列。\n- C++ 標準不保證 rehash 策略；透過 `reserve / max_load_factor` 可影響行為。\n- 老舊編譯器對 C++20/23 API（如 `contains`、`erase_if`）支援度不一。\n\n"
  },
  {
    "id": "cpp-stl-vector",
    "title": "STL std::vector 速查",
    "category": "dataStructure",
    "topics": [
      "C++",
      "STL",
      "Vector",
      "Data Structures"
    ],
    "difficulty": "beginner",
    "description": "連續記憶體的序列容器，支援動態擴張、隨機存取 O(1)，是最常用的容器。",
    "contentPath": "/content/notes/data-structures/cpp-stl-vector.md",
    "createdAt": "2025-10-05",
    "updatedAt": "2025-10-05",
    "markdownContent": "# STL `std::vector` 中文速查（以實務使用為主）\n\n> 以 C++17/20/23 為基準。`std::vector<T>` 是 **連續記憶體（contiguous）** 的序列容器，支援動態擴張、隨機存取（`O(1)`），是最常用的容器。\n\n---\n\n## 1. 什麼時候用 `std::vector`？\n- 需要 **連續記憶體**（與 C 陣列/第三方 API 互通、可用 `&v[0]` / `v.data()`）。\n- **隨機存取 O(1)**、尾端插入/刪除 `push_back/pop_back` 高效（均攤 amortized `O(1)`）。\n- 元素數量會動態變化，但主要在**尾端**變動。若中間頻繁插入/刪除，改用 `std::list`/`deque` 或其他結構。\n\n---\n\n## 2. 關鍵特性與複雜度\n- 迭代器：`random access`。\n- 記憶體：連續配置；**成長時可能重新配置（reallocate）** → 使 **所有 iterator/指標/參考失效**。\n- 主要操作（N = size）\n  - `operator[] / at()`：`O(1)`（`at()`含界限檢查）。\n  - `push_back / emplace_back`：均攤 `O(1)`；成長觸發 reallocate 時為 `O(N)`。\n  - `insert / erase`（非尾端）：`O(N)`（因為需要搬移元素）。\n  - `resize / assign`：`O(N)`（根據新元素建構/拷貝成本）。\n- 容量管理\n  - `size()`：目前元素個數。\n  - `capacity()`：已配置容量（≥ size）。\n  - `reserve(n)`：至少預留容量 n（不改 size）。\n  - `shrink_to_fit()`：**非強制**請求釋放多餘容量（是否真的縮小取決於實作）。\n\n---\n\n## 3. 常見操作範例（最小可用片段）\n\n### 3.1 建立 / 初始化\n```cpp\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    vector<int> a;                 // 空\n    vector<int> b(5);              // 5 個 0\n    vector<int> c(3, 7);           // 3 個 7\n    vector<int> d = {1,2,3};       // init-list\n\n    cout << d.size() << \" \" << d.capacity() << \"\\n\";\n}\n```\n\n### 3.2 讀寫與邊界\n```cpp\nvector<int> v = {10,20,30};\nint x = v[1];         // 20 (無界限檢查)\nint y = v.at(1);      // 20 (有界限檢查，越界拋例外)\nv[2] = 99;\n```\n\n### 3.3 追加 / 擴張 / 縮小\n```cpp\nvector<string> names;\nnames.reserve(1000);              // 預留容量，避免多次重配\nnames.push_back(\"alice\");\nnames.emplace_back(10, 'x');      // 直接建構 \"xxxxxxxxxx\"\n\nnames.resize(5);                  // 若擴大 → 以 T() 填充；若縮小 → 呼叫析構\nnames.resize(7, \"pad\");           // 擴大時以 \"pad\" 填充\nnames.shrink_to_fit();            // 可能縮減容量（非保證）\n```\n\n### 3.4 插入 / 刪除（中間位置）\n```cpp\nvector<int> v = {1,2,3,4};\nv.insert(v.begin()+2, 7);         // {1,2,7,3,4}\nv.erase(v.begin()+1);             // {1,7,3,4}\nv.erase(v.begin()+1, v.begin()+3);// {1,4}  刪掉 [1,3) 範圍\n```\n\n### 3.5 迭代與「邊迭代邊刪除」\n```cpp\nfor (auto it = v.begin(); it != v.end(); ) {\n    if (*it % 2 == 0) it = v.erase(it);   // erase 會回傳下一個 iterator\n    else ++it;\n}\n```\n\n### 3.6 erase-remove 惯用法（刪除符合條件的所有元素）\n```cpp\nvector<int> v = {1,2,3,2,4};\nv.erase(remove(v.begin(), v.end(), 2), v.end());  // 移除所有 2\n// 若要自訂條件：remove_if(v.begin(), v.end(), pred)\n```\n\n### 3.7 取得底層指標\n```cpp\nvector<double> buf = {1.0, 2.0, 3.0};\ndouble* p = buf.data();           // 或 &buf[0]（非空時）\n```\n\n### 3.8 二維 vector\n```cpp\nint n=3,m=4;\nvector<vector<int>> g(n, vector<int>(m, 0));\ng[1][2] = 7;\n```\n\n---\n\n## 4. API 小抄（常用）\n- 構造：`vector()` / `vector(n)` / `vector(n, val)` / `vector(first,last)` / `vector(init_list)`\n- 取值：`operator[]` / `at()` / `front()` / `back()` / `data()`\n- 容量：`size()` / `empty()` / `capacity()` / `reserve(n)` / `shrink_to_fit()`\n- 修改：\n  - 追加：`push_back()` / `emplace_back()` / `append_range(r)`（C++23）\n  - 指定：`assign(n,val)` / `assign(first,last)` / `assign(init_list)`\n  - 插入：`insert(pos, val/count/first,last/init_list)` / `emplace(pos, args...)`\n  - 擴縮：`resize(n)` / `resize(n,val)` / `clear()` / `erase(pos)` / `erase(first,last)` / `swap()`\n- 迭代：`begin()` / `end()` / `rbegin()` / `rend()` / `cbegin()` / `cend()`\n\n> **C++23** `append_range(r)`：將 range 內容追加到尾端（部分實作尚未支援）。\n\n---\n\n## 5. 重要語義與陷阱\n1. **重新配置（reallocation）會使** `迭代器 / 指標 / 參考` **全部失效**：  \n   - 任何 `push_back / insert` 造成容量成長都可能重配。  \n   - 若要維持指標有效：先 `reserve()` 足夠容量。\n2. **`vector<bool>` 特例**：位壓縮的 proxy 型別，不是一般 reference；避免把它當 `bool*` 使用。\n3. **插入/刪除中間元素成本高**：`O(N)` 搬移。若需求頻繁，考慮 `deque`/`list`/其他結構。\n4. **`shrink_to_fit()` 非保證**：是「請求」，可能無效。\n5. **越界存取**：`operator[]` 不檢查界限；需要檢查用 `at()`。\n6. **自訂型別**：大量擴張/搬移會觸發拷貝/移動建構，注意成本；可提供移動建構最佳化。\n7. **與 C API 互通**：用 `data()` 暴露連續記憶體；確保容量足夠避免重配時指標失效。\n\n---\n\n## 6. 效能建議\n- **已知近似大小**：先 `reserve(N)` 減少重配次數。\n- **大量追加**：優先 `emplace_back`（省一次臨時物件）。\n- **批次插入**：`insert(end(), first, last)` 比逐一 `push_back` 更快（實作可能一次擴容）。\n- **避免頻繁縮擴**：預估容量、合併操作，最後再 `shrink_to_fit()`。\n\n---\n\n## 7. 典型練習題型\n- 動態收集結果（例如 backtracking 產生的解集合）。\n- 前綴和、DP 表（連續記憶體有利於快取）。\n- 排序 + 去重（`sort` + `erase(unique(...))`）。\n- 以 `vector<pair/...>>` 儲存圖邊、事件清單等結構。\n\n---\n\n## 8. 迷你測試\n```cpp\nvector<int> v; \nv.reserve(4);\nfor (int i=1;i<=4;++i) v.push_back(i);     // [1,2,3,4]\nauto p = v.data();\nv.push_back(5);                             // 可能 reallocate → p 失效\nv.erase(remove(v.begin(), v.end(), 3), v.end()); // [1,2,4,5]\n```\n\n---\n\n## 9. 備註\n- 多數實作採「倍增」策略擴容（如 x2），但標準未固定策略。  \n- 連續性保證：`&v[i] + 1 == &v[i+1]`。可與 `memcpy`/C API 互通（對 trivially copyable 類型）。\n"
  },
  {
    "id": "trie",
    "title": "Trie（前綴樹）完整筆記 — 概念、實作、用途與題型",
    "category": "dataStructure",
    "topics": [],
    "difficulty": "intermediate",
    "description": "暫無描述",
    "contentPath": "/content/notes/data-structures/trie.md",
    "createdAt": "2024-01-01",
    "updatedAt": "2025-10-12",
    "markdownContent": "> **適合對象**：零基礎～入門程度，想理解「Trie（前綴樹）」是什麼、怎麼實作、何時使用。  \n> **你會學到**：Trie 的核心概念、時間與空間複雜度、實作（C++ 與 Python 版本）、常見坑、延伸變體、典型題目清單。\n\n---\n\n# 1. 什麼是 Trie？（用生活比喻）\nTrie（讀音類似「try」），中文常譯「字典樹／前綴樹」。它把很多**字串**存成一棵樹：  \n- 從根節點出發，每條邊代表**一個字元**；  \n- 一條從根到某個節點的路徑，對應一個**前綴（prefix）**；  \n- 若某個節點被標記為「字尾」，表示**有字串在此結束**。\n\n**比喻**：像電話語音系統「請輸入區碼…」：你每按下一個數字，就走下一層分支。某條完整路徑對應一個完整號碼。\n\n---\n\n# 2. 為什麼用 Trie？（適用場景）\n- **大量字串查詢**：要快速判斷「某字是否存在」、「是否有以某前綴開頭的字」。  \n- **自動補完（Autocomplete）／拼字檢查（Spell Check）**：根據目前輸入的前綴，快速列出候選字。  \n- **統計**：統計某前綴出現次數、統計某字串被插入幾次。  \n- **壓縮共用前綴**：相同開頭只存一次，大幅減少重複儲存。\n\n> 與 **Hash（雜湊）** 比較：Hash 查整字很快，但對「前綴」問題做不到自然支援；Trie 對前綴類查詢非常友善。\n\n---\n\n# 3. 基本操作與複雜度\n假設字元集是小寫英文字母 a–z（26 個）。\n\n- `insert(word)`：逐字走下去，若沒有節點就新建，最後節點標記「是單字結尾」。  \n  - 時間：`O(L)`（L=字長），空間：每個新字母需要新節點（最壞 `O(總字元數)`).  \n- `search(word)`：逐字走下去，若中途缺節點→不存在；走完且結尾標記為真→存在。  \n  - 時間：`O(L)`。  \n- `startsWith(prefix)`：逐字走到 prefix 尾即可，無需結尾標記。  \n  - 時間：`O(P)`（P=前綴長度）。  \n- `erase(word)`（刪除一個字）：把該字的計數減一，必要時回收不再使用的節點。  \n  - 時間：`O(L)`。\n\n> **統計擴充**：在每個節點維護：  \n> - `pass`：有多少字通過這個節點（含結尾在更深處的字）；  \n> - `end`：有多少字在此結尾。  \n> 可支援函式：`countWordsEqualTo(word)`、`countWordsStartingWith(prefix)`。\n\n---\n\n# 4. 視覺化例子（ASCII 圖）\n插入 `[\"to\", \"tea\", \"ted\", \"ten\", \"A\", \"inn\"]`（假設只考慮英文大小寫作為示例）：\n\n```\n(root)\n ├── 'A' (end=1)\n └── 't'\n     └── 'e'\n     │     ├── 'a' (end=1)  → \"tea\"\n     │     ├── 'd' (end=1)  → \"ted\"\n     │     └── 'n' (end=1)  → \"ten\"\n     └── 'o' (end=1)        → \"to\"\n```\n- `\"te\"` 是前綴，但只有當 `end>0` 才代表完整單字。\n\n---\n\n# 5. C++17 實作（英文字母 a–z）\n> 若你的字元集更大（含大小寫、數字、Unicode），請看下方「擴展與進階」。\n\n## 5.1 節點設計（陣列寫法）\n- 使用固定大小 `children[26]` 指向子節點（更快、少額外配置）。  \n- 用 `pass`、`end` 做計數擴充，支援統計與安全刪除。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TrieNode {\n    TrieNode* child[26];\n    int pass; // 經過此節點的字串數\n    int end;  // 在此結點結尾的字串數\n\n    TrieNode() : pass(0), end(0) {\n        memset(child, 0, sizeof(child));\n    }\n};\n\nclass Trie {\nprivate:\n    TrieNode* root;\n\n    void freeSubtree(TrieNode* node) {\n        if (!node) return;\n        for (int i = 0; i < 26; ++i) {\n            if (node->child[i]) freeSubtree(node->child[i]);\n        }\n        delete node;\n    }\n\npublic:\n    Trie() { root = new TrieNode(); }\n    ~Trie() { freeSubtree(root); }\n\n    void insert(const string& word) {\n        TrieNode* cur = root;\n        cur->pass++;\n        for (char ch : word) {\n            int idx = ch - 'a';\n            if (!cur->child[idx]) cur->child[idx] = new TrieNode();\n            cur = cur->child[idx];\n            cur->pass++;\n        }\n        cur->end++;\n    }\n\n    bool search(const string& word) const {\n        const TrieNode* cur = root;\n        for (char ch : word) {\n            int idx = ch - 'a';\n            if (!cur->child[idx]) return false;\n            cur = cur->child[idx];\n        }\n        return cur->end > 0;\n    }\n\n    bool startsWith(const string& prefix) const {\n        const TrieNode* cur = root;\n        for (char ch : prefix) {\n            int idx = ch - 'a';\n            if (!cur->child[idx]) return false;\n            cur = cur->child[idx];\n        }\n        return true;\n    }\n\n    int countWordsEqualTo(const string& word) const {\n        const TrieNode* cur = root;\n        for (char ch : word) {\n            int idx = ch - 'a';\n            if (!cur->child[idx]) return 0;\n            cur = cur->child[idx];\n        }\n        return cur->end;\n    }\n\n    int countWordsStartingWith(const string& prefix) const {\n        const TrieNode* cur = root;\n        for (char ch : prefix) {\n            int idx = ch - 'a';\n            if (!cur->child[idx]) return 0;\n            cur = cur->child[idx];\n        }\n        return cur->pass;\n    }\n\n    bool erase(const string& word) {\n        // 先確認存在\n        TrieNode* cur = root;\n        vector<pair<TrieNode*, int>> stk;\n        for (char ch : word) {\n            int idx = ch - 'a';\n            if (!cur->child[idx] || cur->child[idx]->pass == 0) return false;\n            stk.push_back({cur, idx});\n            cur = cur->child[idx];\n        }\n        if (cur->end == 0) return false;\n\n        // 實際刪除：end--，沿路 pass--，如 pass=0 釋放子樹\n        cur->end--;\n        cur = root;\n        for (char ch : word) {\n            int idx = ch - 'a';\n            TrieNode* nxt = cur->child[idx];\n            nxt->pass--;\n            if (nxt->pass == 0) {\n                freeSubtree(nxt);\n                cur->child[idx] = nullptr;\n                break;\n            }\n            cur = nxt;\n        }\n        return true;\n    }\n};\n```\n\n### 使用範例\n```cpp\nint main() {\n    Trie trie;\n    trie.insert(\"apple\");\n    trie.insert(\"app\");\n    trie.insert(\"apple\");\n\n    cout << boolalpha;\n    cout << trie.search(\"apple\") << \"\\n\";     // true\n    cout << trie.search(\"appl\") << \"\\n\";      // false\n    cout << trie.startsWith(\"ap\") << \"\\n\";    // true\n    cout << trie.countWordsEqualTo(\"apple\") << \"\\n\";       // 2\n    cout << trie.countWordsStartingWith(\"app\") << \"\\n\";    // 3\n    cout << trie.erase(\"apple\") << \"\\n\";                   // true\n    cout << trie.countWordsEqualTo(\"apple\") << \"\\n\";       // 1\n    cout << trie.erase(\"banana\") << \"\\n\";                  // false\n}\n```\n\n---\n\n## 5.2 map/unordered_map 寫法（支援更大字元集）\n```cpp\nstruct Node {\n    unordered_map<char, Node*> next;\n    int pass = 0, end = 0;\n    ~Node() {\n        for (auto &kv : next) delete kv.second;\n    }\n};\n\nclass Trie2 {\n    Node* root;\npublic:\n    Trie2(): root(new Node()) {}\n    ~Trie2(){ delete root; }\n\n    void insert(const string& s) {\n        Node* cur = root;\n        cur->pass++;\n        for (char c : s) {\n            if (!cur->next.count(c)) cur->next[c] = new Node();\n            cur = cur->next[c];\n            cur->pass++;\n        }\n        cur->end++;\n    }\n\n    bool search(const string& s) const {\n        const Node* cur = root;\n        for (char c : s) {\n            auto it = cur->next.find(c);\n            if (it == cur->next.end()) return false;\n            cur = it->second;\n        }\n        return cur->end > 0;\n    }\n\n    bool startsWith(const string& pre) const {\n        const Node* cur = root;\n        for (char c : pre) {\n            auto it = cur->next.find(c);\n            if (it == cur->next.end()) return false;\n            cur = it->second;\n        }\n        return true;\n    }\n\n    int countWordsEqualTo(const string& s) const {\n        const Node* cur = root;\n        for (char c : s) {\n            auto it = cur->next.find(c);\n            if (it == cur->next.end()) return 0;\n            cur = it->second;\n        }\n        return cur->end;\n    }\n\n    int countWordsStartingWith(const string& pre) const {\n        const Node* cur = root;\n        for (char c : pre) {\n            auto it = cur->next.find(c);\n            if (it == cur->next.end()) return 0;\n            cur = it->second;\n        }\n        return cur->pass;\n    }\n};\n```\n\n---\n\n# 6. Python 版本（更易讀）\n```python\nclass TrieNode:\n    __slots__ = (\"next\", \"pass_cnt\", \"end_cnt\")\n    def __init__(self):\n        self.next = {}        # char -> TrieNode\n        self.pass_cnt = 0\n        self.end_cnt = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        cur = self.root\n        cur.pass_cnt += 1\n        for ch in word:\n            if ch not in cur.next:\n                cur.next[ch] = TrieNode()\n            cur = cur.next[ch]\n            cur.pass_cnt += 1\n        cur.end_cnt += 1\n\n    def search(self, word: str) -> bool:\n        cur = self.root\n        for ch in word:\n            if ch not in cur.next:\n                return False\n            cur = cur.next[ch]\n        return cur.end_cnt > 0\n\n    def startsWith(self, prefix: str) -> bool:\n        cur = self.root\n        for ch in prefix:\n            if ch not in cur.next:\n                return False\n            cur = cur.next[ch]\n        return True\n\n    def countWordsEqualTo(self, word: str) -> int:\n        cur = self.root\n        for ch in word:\n            if ch not in cur.next: return 0\n            cur = cur.next[ch]\n        return cur.end_cnt\n\n    def countWordsStartingWith(self, prefix: str) -> int:\n        cur = self.root\n        for ch in prefix:\n            if ch not in cur.next: return 0\n            cur = cur.next[ch]\n        return cur.pass_cnt\n\n    def erase(self, word: str) -> bool:\n        # 確認存在\n        cur = self.root\n        stack = [cur]\n        for ch in word:\n            if ch not in cur.next: return False\n            cur = cur.next[ch]\n            stack.append(cur)\n        if cur.end_cnt == 0: return False\n\n        # 刪除計數\n        cur.end_cnt -= 1\n        for node in stack:\n            node.pass_cnt -= 1\n\n        # 清理孤兒\n        cur = self.root\n        for ch in word:\n            nxt = cur.next[ch]\n            if nxt.pass_cnt == 0:\n                del cur.next[ch]\n                break\n            cur = nxt\n        return True\n```\n\n---\n\n# 7. 常見坑（初學者必看）\n1. **大小寫／非英文字元**：若限定 a–z，請先轉小寫；否則改用 map 版本。  \n2. **結尾標記**：`search` 要檢查 `end>0`；只到節點不代表是完整單字。  \n3. **重複插入與刪除**：用 `end`、`pass` 維護計數，支援多次插入／刪除。  \n4. **記憶體釋放（C++）**：務必回收無用節點。  \n5. **Unicode**：可改以 codepoint 為單位（python 自然支援；C++ 可考慮 `char32_t`）。  \n6. **效率權衡**：陣列 vs map/unordered_map 視字元集大小選擇。\n\n---\n\n# 8. 進階與變體\n- **壓縮 Trie（Radix/Patricia）**：把單鏈路徑壓成一段字串，節省空間。  \n- **Aho–Corasick**：多模式匹配（敏感詞），在 Trie 上加 fail 指針。  \n- **Bitwise Trie（數位樹）**：按位儲存整數，用於最大 XOR 等題。  \n- **Ternary Search Tree**：以 BST 思想按字元分支，省空間且支持字典序操作。\n\n---\n\n# 9. 典型題目\n- LC 208 Implement Trie (Prefix Tree) — 基礎 CRUD  \n- LC 211 Add and Search Word — 搜尋支援 '.' 萬用字（Trie+回溯）  \n- LC 212 Word Search II — 盤面找字（Trie+DFS）  \n- LC 648 Replace Words — 字典替換  \n- LC 421 Maximum XOR of Two Numbers — Bitwise Trie  \n- LC 1032 Stream of Characters — 逆向 Trie 線上匹配\n\n---\n\n# 10. 小結\n- Trie 以「字元路徑」呈現多字串共享前綴，前綴查詢 `O(L)` 高效直覺。  \n- 初學者先用 a–z 陣列版，熟悉後再擴展到 map 版、多語系、壓縮 Trie 與 Aho–Corasick。\n\n---\n\n# 11. 速查表\n- 插入：走到底、`pass++`、`end++`。  \n- 搜尋：走到底、判 `end>0`。  \n- 前綴：走到 prefix 即成功。  \n- 刪除：`end--`、沿路 `pass--`，必要時刪孤兒。  \n- 複雜度：均攤 `O(L)`；空間 ~ 節點數。\n"
  },
  {
    "id": "prefix-suffix-precompute",
    "title": "前綴 / 後綴預計算與應用",
    "category": "technique",
    "topics": [
      "Prefix",
      "Suffix",
      "Precompute",
      "Array"
    ],
    "difficulty": "intermediate",
    "description": "預先計算累積資訊一次 → 回答多次查詢或在 O(1)/O(log n) 內驗證約束條件。",
    "contentPath": "/content/notes/techniques/prefix-suffix-precompute.md",
    "createdAt": "2025-10-05",
    "updatedAt": "2025-10-05",
    "markdownContent": "# 前綴 / 後綴預計算與應用\n\n## 0. 概述\n- **概念名稱**：前綴 / 後綴預計算（總和、最小/最大值、單調性等）\n- **類別**：演算法預處理\n- **標籤**：prefix sum, suffix sum, prefix min/max, inc/dec flags, feasibility checks, difference array, 2D prefix sum, XOR prefix\n- **前置知識**：陣列、基礎數學、時間/空間權衡\n- **熟悉度（1–5）**：3\n- **最後更新**：2025-10-05 (UTC+8)\n\n---\n\n## 1. 核心概念（What & Why）\n**預先計算累積資訊一次 → 回答多次查詢或在 O(1)/O(log n) 內驗證約束條件。**\n- **前綴**在索引 `i` 處總結從開頭到 `i` 的資料（例如：總和/最小值/最大值/遞增驗證）。\n- **後綴**在索引 `i` 處總結從 `i` 到結尾的資料。\n- 將它們結合以快速評估分割/切割、範圍和可行性。\n\n**何時使用**\n- 多次**範圍**查詢。\n- 需要在**每個切點檢查可行性**（例如：前綴嚴格遞增**且**後綴嚴格遞減）。\n- 將昂貴的每次查詢成本 → 在 O(n) 預處理後變成便宜的常數時間。\n\n---\n\n## 2. 標準構造方式\n\n### 2.1 前綴和（1D）\n- `pref[i] = a[0] + ... + a[i]`（使用 64 位元以避免溢位）\n- 範圍和 `[l..r] = pref[r] − (l>0 ? pref[l‑1] : 0)`\n\n**C++ 程式碼片段**\n```cpp\nvector<long long> pref(n);\npref[0] = a[0];\nfor (int i = 1; i < n; ++i) pref[i] = pref[i-1] + a[i];\n\nauto range_sum = [&](int l, int r) -> long long {\n    return pref[r] - (l ? pref[l-1] : 0LL);\n};\n```\n\n### 2.2 後綴和\n```cpp\nvector<long long> suff(n);\nsuff[n-1] = a[n-1];\nfor (int i = n-2; i >= 0; --i) suff[i] = suff[i+1] + a[i];\n```\n\n### 2.3 前綴最小/最大 & 後綴最小/最大\n- `pmin[i] = min(a[0..i])`, `pmax[i] = max(a[0..i])`\n- `smin[i] = min(a[i..n-1])`, `smax[i] = max(a[i..n-1])`\n\n### 2.4 單調性標記（遞增/遞減可行性）\n- `inc[i] = inc[i-1] && (a[i-1] < a[i])`（嚴格遞增前綴）\n- `dec[i] = dec[i+1] && (a[i] > a[i+1])`（嚴格遞減後綴）\n\n### 2.5 前綴 XOR / AND / OR / GCD\n- XOR: `px[i] = px[i-1] ^ a[i]` → 在 O(1) 內得到範圍 XOR。\n- GCD: `pg[i] = gcd(pg[i-1], a[i])`, `sg[i] = gcd(a[i], sg[i+1])` → 透過 `gcd(pg[l-1], sg[r+1])` 得到範圍 gcd。\n\n### 2.6 差分陣列（範圍加法 O(1)，最後用前綴處理）\n- 在 `[l..r]` 加 `+v`: `diff[l] += v; diff[r+1] -= v;`\n- 還原: `arr = prefix(diff)`。\n\n### 2.7 2D 前綴和（積分影像）\n- `P[i][j] = sum of A[0..i][0..j]`\n- 矩形和 `(r1..r2, c1..c2)` 透過容斥原理計算。\n\n---\n\n## 3. 典型應用\n\n1. **範圍和 / XOR 查詢**：當只需要總和/XOR 時，可作為 RMQ 的替代方案。\n2. **平衡 / 分割問題**：在約束條件下最小化 `|sum(left) − sum(right)|`。\n3. **切點可行性**：例如 `inc[i] && dec[i+1]` 確保左邊嚴格遞增且右邊嚴格遞減。\n4. **排除一個元素的 GCD**：`除了 a[k] 的所有元素的 gcd = gcd(pg[k-1], sg[k+1])`。\n5. **閾值 / 邊界測試**：前綴最小值 vs 當前值，或後綴最大值 vs 當前值。\n6. **差分陣列**：多次範圍更新 + 一次最終處理。\n7. **2D 範圍和**：在 O(1) 內進行子矩陣查詢。\n\n---\n\n## 4. 模式 —「枚舉切點並預計算可行性」\n**目標**：快速檢查在 `i` 之後切割是否有效，然後評估指標（例如：總和差異）。\n\n**步驟**\n1. 建立 `inc[0..i]` 和 `dec[i+1..]` 標記。\n2. 建立 `pref` 以在 O(1) 內得到左/右總和。\n3. 迴圈所有 `i` (0..n‑2)，若可行：計算指標並取最小/最大值。\n\n**虛擬碼**\n```text\nbuild inc[], dec[], pref[]\nbest = +INF\nfor i in 0..n-2:\n    if inc[i] && dec[i+1]:\n        left  = pref[i]\n        right = pref[n-1] - pref[i]\n        best = min(best, |left - right|)\nreturn best or -1 if no feasible\n```\n\n---\n\n## 5. 邊界情況與陷阱\n- **嚴格 vs 非嚴格**：正確使用 `<` / `>` vs `<=` / `>=`。\n- **單一元素子陣列**：通常計為嚴格單調；確認題目說明。\n- **溢位**：對總和使用 `long long`；注意 2D 總和。\n- **索引**：`pref[r] − pref[l-1]` 模式；保護 `l=0`。\n- **空邊**：枚舉切點時，確保兩邊都非空（`i ≤ n‑2`）。\n- **2D 邊界**：容斥原理的 off-by-one。\n- **差分陣列最終處理**：別忘了最後的前綴處理。\n\n---\n\n## 6. 微練習\n1. 為陣列建立 `inc[]` / `dec[]` 並計算有多少可行的切點存在。\n2. 給定查詢 `[l,r]`，用 `pref[]` 和 `suff[]` 回答 `sum(l,r)`（練習兩者）。\n3. 用 1D 差分陣列實作「範圍加法更新 + 點查詢」。\n4. 實作 2D 前綴和並查詢矩形總和。\n5. 用前綴/後綴 GCD 陣列實作排除一個元素的 GCD。\n\n---\n\n## 7. C++ 最小骨架\n\n**前綴/後綴和 & 可行性**\n```cpp\nvector<long long> pref(n);\npref[0] = a[0];\nfor (int i = 1; i < n; ++i) pref[i] = pref[i-1] + a[i];\n\nvector<char> inc(n, 0), dec(n, 0);\ninc[0] = 1;\nfor (int i = 1; i < n; ++i) inc[i] = inc[i-1] && (a[i-1] < a[i]);\ndec[n-1] = 1;\nfor (int i = n-2; i >= 0; --i) dec[i] = dec[i+1] && (a[i] > a[i+1]);\n```\n\n**差分陣列**\n```cpp\nvector<long long> diff(n+1);\nauto add = [&](int l, int r, long long v){\n    diff[l] += v;\n    if (r+1 < (int)diff.size()) diff[r+1] -= v;\n};\nvector<long long> arr(n);\nlong long run = 0;\nfor (int i = 0; i < n; ++i) { run += diff[i]; arr[i] = run; }\n```\n\n**2D 前綴（簡要）**\n```cpp\nvector<vector<long long>> P(n+1, vector<long long>(m+1));\nfor (int i = 1; i <= n; ++i)\n  for (int j = 1; j <= m; ++j)\n    P[i][j] = A[i][j] + P[i-1][j] + P[i][j-1] - P[i-1][j-1];\n\nauto rect = [&](int r1,int c1,int r2,int c2){\n  return P[r2][c2]-P[r1-1][c2]-P[r2][c1-1]+P[r1-1][c1-1];\n};\n```\n\n---\n\n## 8. 相關概念\n- 滑動視窗（當範圍連續且移動 1 時）。\n- Fenwick Tree / Segment Tree（帶 log 因子的範圍查詢/更新）。\n- 單調堆疊/佇列（不同的「單調」但常與前綴資訊配對）。\n- 稀疏表（等冪範圍查詢，如 min/max）。\n\n---\n\n## 9. 編碼前快速檢查清單\n- 決定嚴格 vs 非嚴格。\n- 如果值可能很大或數量很多，選擇 64 位元總和。\n- 確認切點範圍（確保兩邊非空）。\n- 僅預計算所需內容（總和？最小值？標記？gcd？）。\n- 為 `n=1/2`、相等元素、負數、大值加入測試。\n\n---\n\n## 10. 個人筆記\n- 對於有約束條件的分割陣列問題，**inc/dec + 前綴和**是強大的 O(n) 模式。\n- 當有**多次範圍更新**但只有一次最終讀取時，差分陣列很好用。\n- 2D 前綴和通常是無更新的子矩陣查詢的最快路徑。\n"
  }
];

export function getNotesByCategory(category: keyof typeof NOTE_CATEGORIES): Note[] {
  return NOTES.filter(note => note.category === category);
}

export function getNotesByTopic(topic: string): Note[] {
  return NOTES.filter(note => 
    note.topics.some(t => t.toLowerCase() === topic.toLowerCase())
  );
}

export function getNoteById(id: string): Note | undefined {
  return NOTES.find(note => note.id === id);
}
